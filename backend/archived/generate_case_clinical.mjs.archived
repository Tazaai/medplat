// backend/generate_case_clinical.mjs
// SIMPLIFIED: One-shot generator - removed all deprecated multi-engine architecture
// Only uses: Stage A + Stage B GPT-4o generation + post-processing

import OpenAI from "openai";
import { withTimeoutAndRetry } from "./utils/api_helpers.mjs";
import {
  postProcessCase
} from "./utils/case_post_processor.mjs";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

/**
 * Generate a fully structured clinical case using MedPlat Universal System.
 * @param {Object} params
 * @param {String} params.topic
 * @param {String} params.category
 * @param {String} params.model
 * @param {String} params.lang
 * @param {String} params.region
 * @param {Boolean} params.mcq_mode - If true, include MCQs in response
 * @returns {Object} Parsed clinical case JSON
 */
export async function generateClinicalCase({
  topic,
  category,
  model = "gpt-4o",
  lang = "en",
  region = "auto",
  mcq_mode = false,
  mode = "classic", // classic | gamified | simulation
}) {
  // ============================================================
  // DEPRECATED: This generator is being replaced by multi-step /api/case endpoints
  // ============================================================
  const DIAGNOSTIC_MODE = false; // Deprecated - use /api/case endpoints instead
  
  // DEFENSIVE: Define sanitized variables in function scope (accessible in catch block)
  let sanitizedTopic, sanitizedCategory, sanitizedLang, sanitizedRegion, sanitizedMode;
  
  try {
    // DEFENSIVE CHECKS: Validate and sanitize inputs to prevent 500 errors
    if (!topic || typeof topic !== "string" || topic.trim().length === 0) {
      console.error("[GENERATE_CASE] ‚ùå Invalid topic input:", { topic, type: typeof topic });
      throw new Error("Invalid topic: topic must be a non-empty string");
    }
    
    // Sanitize topic (remove extra whitespace, ensure it's a string)
    sanitizedTopic = String(topic).trim();
    if (sanitizedTopic.length === 0) {
      console.error("[GENERATE_CASE] ‚ùå Topic empty after sanitization:", { original: topic });
      throw new Error("Invalid topic: topic cannot be empty after sanitization");
    }
    
    // Sanitize category (provide fallback if missing)
    sanitizedCategory = category && typeof category === "string" && category.trim().length > 0 
      ? String(category).trim() 
      : "General Practice";
    
    // Sanitize other inputs
    sanitizedLang = lang && typeof lang === "string" ? String(lang).trim() : "en";
    sanitizedRegion = region && typeof region === "string" ? String(region).trim() : "global";
    sanitizedMode = mode && typeof mode === "string" ? String(mode).trim() : "classic";
    
    console.log('[GENERATE_CASE] Input validation:', {
      topic: sanitizedTopic,
      category: sanitizedCategory,
      lang: sanitizedLang,
      region: sanitizedRegion,
      mode: sanitizedMode
    });

    // TWO-STAGE PIPELINE: Both stages use gpt-4o for maximum quality
    const stageAModel = "gpt-4o";
    const stageBModel = "gpt-4o";

    // SIMPLIFIED: Removed all domain detection and engine logic - pure one-shot generation

    // DEFENSIVE: Ensure prompt variables are safe strings (prevent undefined/null in template)
    const safePromptTopic = sanitizedTopic || "Clinical Case";
    const safePromptCategory = sanitizedCategory || "General Practice";
    const safePromptRegion = sanitizedRegion || "global";
    const safePromptLang = sanitizedLang || "en";
    const safePromptMode = sanitizedMode || "classic";
    
    // ============================================================
    // HELPER FUNCTION: Retry Stage B per-block if full Stage B fails
    // ============================================================
    async function retryStageBPerBlock(stageAOutput, topic, category, region, basePrompt) {
      console.log('[GENERATE_CASE] üîÑ STAGE B RETRY: Regenerating missing blocks individually...');
      const blocks = [
        { name: 'complications', path: 'management.complications', prompt: 'Generate complications (immediate, early, late - 2-4 items each)' },
        { name: 'pharmacology', path: 'management.pharmacology', prompt: 'Generate pharmacology (medications, dosing_ranges, adjustments, monitoring, contraindications, interactions)' },
        { name: 'diagnostic_evidence', path: 'paraclinical.diagnostic_evidence', prompt: 'Generate diagnostic evidence metrics (sensitivity, specificity, likelihood_ratio, likelihood_modification)' },
        // Removed: guidelines block - guidelines removed from system
        { name: 'pathophysiology_detail', path: 'pathophysiology_detail', prompt: 'Generate deep pathophysiology (cellular_molecular, organ_microanatomy, mechanistic_links, compensatory_pathways)' },
        { name: 'expert_conference', path: 'expert_conference', prompt: 'Generate expert conference (Dr A-D format with disagreements and consensus)' }
      ];
      
      const result = {};
      
      for (const block of blocks) {
        try {
          console.log(`[GENERATE_CASE] üîÑ Retrying block: ${block.name}...`);
          const blockCompletion = await client.chat.completions.create({
            model: stageBModel, // Use gpt-4o
            response_format: { type: "json_object" },
            messages: [
              { role: "system", content: `${basePrompt}\n\nGenerate ONLY the ${block.name} section.` },
              {
                role: "user",
                content: `${block.prompt} for topic: ${topic}, category: ${category}, region: ${region}. Case context: ${JSON.stringify({ history: stageAOutput.history?.substring(0, 100), final_diagnosis: stageAOutput.final_diagnosis }).substring(0, 300)}. Return JSON with only the ${block.name} field.`
              }
            ],
            temperature: 0.3,
            max_tokens: 2000
          });
          
          const blockText = blockCompletion.choices?.[0]?.message?.content || "{}";
          const blockParsed = JSON.parse(blockText.replace(/```json/g, "").replace(/```/g, ""));
          
          if (block.path.includes('.')) {
            const [parent, child] = block.path.split('.');
            if (!result[parent]) result[parent] = {};
            result[parent][child] = blockParsed[block.name] || blockParsed[child] || blockParsed;
          } else {
            result[block.name] = blockParsed[block.name] || blockParsed;
          }
          
          console.log(`[GENERATE_CASE] ‚úÖ Block ${block.name} regenerated successfully`);
        } catch (blockError) {
          console.error(`[GENERATE_CASE] ‚ùå Block ${block.name} retry failed:`, blockError.message);
          // Fallback structures
          if (block.name === 'complications') {
            if (!result.management) result.management = {};
            result.management.complications = { immediate: [], early: [], late: [] };
          } else if (block.name === 'pharmacology') {
            if (!result.management) result.management = {};
            result.management.pharmacology = { medications: [], dosing_ranges: {}, adjustments: {}, monitoring: {}, contraindications: {}, interactions: {} };
          } else if (block.name === 'diagnostic_evidence') {
            if (!result.paraclinical) result.paraclinical = {};
            result.paraclinical.diagnostic_evidence = { evidence_metrics: {}, likelihood_modification: '' };
          // Removed: guidelines fallback - guidelines removed from system
          } else if (block.name === 'pathophysiology_detail') {
            result.pathophysiology_detail = { cellular_molecular: '', organ_microanatomy: '', mechanistic_links: '', compensatory_pathways: '' };
          } else if (block.name === 'expert_conference') {
            result.expert_conference = { voices: [], disagreements: [], consensus: '' };
          }
        }
      }
      
      return result;
    }
    
    // ============================================================
    // DIAGNOSTIC MODE: Single direct GPT-4o call (bypasses all correction layers)
    // ============================================================
    if (DIAGNOSTIC_MODE) {
      console.log('[GENERATE_CASE] üî¥ DIAGNOSTIC MODE: Bypassing all correction layers, using single direct GPT-4o call');
      
      // Single direct generation call with full original prompt
      const diagnosticCompletion = await withTimeoutAndRetry(
        async () =>
          await client.chat.completions.create({
            model: "gpt-4o",
            response_format: { type: "json_object" },
            messages: [
              { role: "system", content: systemPrompt },
              {
                role: "user",
                content: `Generate complete clinical case for topic: "${safePromptTopic}", category: "${safePromptCategory}", region: ${safePromptRegion}. Return valid JSON.`,
              },
            ],
            temperature: 0.4,
          }),
        120000, // 2 minutes
        1
      );
      
      const diagnosticText = diagnosticCompletion.choices?.[0]?.message?.content || "{}";
      let diagnosticParsed;
      
      try {
        diagnosticParsed = JSON.parse(diagnosticText);
      } catch (err) {
        const cleaned = diagnosticText.replace(/```json/g, "").replace(/```/g, "");
        diagnosticParsed = JSON.parse(cleaned);
      }
      
      console.log('[GENERATE_CASE] ‚úÖ DIAGNOSTIC MODE: Raw GPT-4o output received, returning without modification');
      console.log('[GENERATE_CASE] üìã DIAGNOSTIC MODE: Full case output:', JSON.stringify(diagnosticParsed, null, 2));
      
      // Return raw JSON without any modification
      return diagnosticParsed;
    } // End DIAGNOSTIC_MODE early return
    
    // ============================================================
    // NORMAL MODE: TWO-STAGE PIPELINE: Stage A (gpt-4o) + Stage B (gpt-4o)
    // ============================================================
    
    // STAGE A: Generate basic case structure with gpt-4o
    const stageAPrompt = `You are MedPlat's clinical case generator - STAGE A (Basic Structure).

Generate ONLY the following sections for topic "${sanitizedTopic}":

REQUIRED SECTIONS (ONLY these):
1. history (6-10 sentences with timeline, risk factors, systemic review)
2. physical_exam (5-8 sentences with full vital set: BP, HR, RR, Temp, SpO2)
   - Use standard international units. Temperature in Celsius (¬∞C).
   - Never include raw JSON blocks or curly braces.
3. paraclinical.labs (lab values with interpretations)
   - Use SI units. Include normal ranges ONLY when clinically relevant, format as "N: X‚ÄìY" with interpretation (normal | high | low | borderline).
   - When relevant (troponin, CK-MB, D-dimer, cultures, LP), include ONE short sentence about timing/dynamics.
   - Never include raw JSON blocks.
4. paraclinical.imaging (imaging findings with interpretations)
   - Include brief decision reasoning (CT vs MRI vs US) when relevant: CT for emergencies/perforation/hemorrhage, US for gallbladder/DVT/pediatrics, MRI for neurology/soft tissue/spine.
   - When relevant, include ONE short sentence about when imaging becomes diagnostic or repeat timing.
   - Never include raw JSON blocks.
5. final_diagnosis (specific diagnosis string)
6. differential_diagnoses (4-6 items with name, tier, for, against - base structure only)
7. meta (basic metadata: topic, category, age, sex, setting, region_guideline_source)

FORBIDDEN: Do NOT generate:
- complications
- pharmacology
- diagnostic_evidence (metrics)
- pathophysiology_detail (deep structure)
- expert_conference
- management (beyond basic initial/definitive strings)

OUTPUT FORMAT (JSON):
{
  "meta": {
    "topic": "${sanitizedTopic}",
    "category": "${sanitizedCategory}",
    "age": "",
    "sex": "",
    "setting": "",
    "region_guideline_source": "${sanitizedRegion}"
  },
  "history": "",
  "physical_exam": "",
  "paraclinical": {
    "labs": "",
    "imaging": ""
  },
  "differential_diagnoses": [
    {"name": "...", "tier": "1/2/3", "for": "...", "against": "..."}
  ],
  "final_diagnosis": ""
}

Return ONLY valid JSON. Never include placeholders, guidelines, references, or mechanical markers.`;

    // STAGE B: Upgrade complex sections with gpt-4o (high-quality)
    const stageBPrompt = `You are MedPlat's clinical case generator - STAGE B (Complex Sections Upgrade).

You are upgrading a clinical case that already has basic structure (history, exam, paraclinical, diagnosis, differentials).

Generate ONLY the following complex sections:

REQUIRED SECTIONS (ONLY these):
1. management.complications (immediate, early, late - 2-4 items each, aligned with acuity/phase)
2. management.pharmacology (medications, dosing_ranges, adjustments, monitoring, contraindications, interactions)
   - Use standard international units. Keep concise and professional.
3. paraclinical.diagnostic_evidence (evidence_metrics: sensitivity, specificity, likelihood_ratio, likelihood_modification)
4. pathophysiology_detail (deep structured: cellular_molecular, organ_microanatomy, mechanistic_links, compensatory_pathways)
   - Use exam-level detail with short histophysiology layer when meaningful.
   - Include: cellular/molecular trigger, organ-level dysfunction, systemic consequence, compensatory mechanisms.
5. expert_conference (Dr A-D format: voices with "Dr A (Specialist)", "Dr B (Emergency Medicine)", etc., disagreements array, consensus)
   - Use natural language, no mechanical markers like [Disagreement] or [Consensus].
   - Keep concise, professional, globally understandable.

CONTEXT FROM STAGE A:
${JSON.stringify({
  topic: sanitizedTopic,
  category: sanitizedCategory,
  history: "See Stage A output",
  physical_exam: "See Stage A output",
  final_diagnosis: "See Stage A output",
  differential_diagnoses: "See Stage A output"
}, null, 2)}

OUTPUT FORMAT (JSON - ONLY these fields):
{
  "management": {
    "complications": {
      "immediate": [],
      "early": [],
      "late": []
    },
    "pharmacology": {
      "medications": [],
      "dosing_ranges": {},
      "adjustments": {},
      "monitoring": {},
      "contraindications": {},
      "interactions": {}
    }
  },
  "paraclinical": {
    "diagnostic_evidence": {
      "evidence_metrics": {
        "sensitivity": "",
        "specificity": "",
        "likelihood_ratio": ""
      },
      "likelihood_modification": ""
    }
  },
  // Removed: guidelines - guidelines removed from system
  "pathophysiology_detail": {
    "cellular_molecular": "",
    "organ_microanatomy": "",
    "mechanistic_links": "",
    "compensatory_pathways": ""
  },
  "expert_conference": {
    "voices": [
      {"role": "Dr A (Specialist)", "position": "", "evidence": ""},
      {"role": "Dr B (Emergency Medicine)", "position": "", "evidence": ""},
      {"role": "Dr C (General Practice)", "position": "", "evidence": ""},
      {"role": "Dr D (Intensivist)", "position": "", "evidence": ""}
    ],
    "disagreements": [
      {"topic": "", "dr_a_position": "", "dr_b_position": "", "resolution": ""}
    ],
    "consensus": ""
  }
}

Return ONLY valid JSON. Never include placeholders, guidelines, references, raw JSON blocks, or mechanical markers.`;

    // QUALITY MODE: Enhanced prompt for gpt-4o (LEGACY - kept for reference, but Stage A uses stageAPrompt)
    // UNIVERSAL DYNAMIC CORE: Fully dynamic case generation
    // SIMPLIFIED PROMPT FOR DIAGNOSTIC MODE TESTING
    const systemPrompt = `You are MedPlat's universal clinical case generator.

Target Audience:
This platform serves medical doctors, medical students, clinical researchers, and USMLE Step 2 / clinical exam candidates. Output must be suitable for clinical teaching and exam preparation at a professional level. All clinical language must be exam-level for USMLE Step 2, doctors, medical students, and clinical researchers ‚Äî concise, professional, and globally understandable.

Goal:
Generate a single, coherent, high-quality clinical case for the given topic and category, as structured JSON that matches the existing MedPlat schema.

Core requirements:
- Case must be realistic, clinically consistent, and exam-level.
- Everything must be specific to the requested topic and category.
- No placeholders like "Not provided", "Examination pending", "No justification provided", "See case analysis", "[object Object]".
- All arrays and fields must contain meaningful content or be omitted, not left as empty boilerplate.

Output:
Return ONLY valid JSON (no Markdown, no prose). Use this structure (keys must exist, values must be meaningful):

{
  "meta": {
    "topic": string,
    "category": string,
    "age": string,
    "sex": string,
    "setting": string,
    "region_guideline_source": string,
    "disease_subtype": string,
    "severity_grade": string,
    "temporal_phase": string,
    "primary_diagnosis": string,
    "secondary_diagnoses": string[],
    "generator_quality_score": number,
    "overview": string
  },
  "history": string,
  "physical_exam": string,
  "paraclinical": {
    "labs": string,
    "imaging": string,
    "diagnostic_evidence": {
      "sensitivity": string,
      "specificity": string,
      "ppv": string,
      "npv": string,
      "likelihood_ratios": string,
      "diagnostic_traps": string,
      "imaging_misses": string
    }
  },
  "differential_diagnoses": [
    {
      "name": string,
      "tier": "top" | "middle" | "rare",
      "for": string,
      "against": string,
      "justification": string
    }
  ],
  "final_diagnosis": string,
  "management": {
    "initial": string,
    "definitive": string,
    "pharmacology": {
      "key_drugs": string[],
      "mechanisms_of_action": string,
      "dosing_adjustments": string,
      "contraindicated_medications": string,
      "stepwise_escalation": string,
      "drug_disease_interactions": string
    },
    "treatment_thresholds": string,
    "complications": {
      "immediate": string[],
      "early": string[],
      "late": string[]
    }
  },
  "red_flags": string[],
  "red_flag_hierarchy": {
    "critical": string[],
    "important": string[],
    "rare_dangerous": string[]
  },
  "key_points": string[],
  "expert_conference": string,
  "pathophysiology": string,
  "pathophysiology_detail": {
    "cellular_molecular": string,
    "organ_microanatomy": string,
    "mechanistic_links": string,
    "compensatory_pathways": string,
    "text_diagrams": string
  },
  "reasoning_chain": string[],
  "counterfactuals": string,
  "crucial_concepts": string,
  "common_pitfalls": string,
  "exam_notes": string,
  "exam_pearls": string,
  "comparison_tables": string,
  "next_best_step_algorithms": string,
  "risk_scores": {},
  // Removed: guidelines - guidelines removed from system
  "clinical_risk_assessment": string,
  "next_diagnostic_steps": string,
  "bedside_vs_advanced": string,
  "comorbidity_reasoning": string,
  "mcqs": [],
  "simulation_steps": [],
  "interaction_points": [],
  "vitals_timeline": [],
  "branching_logic": {},
  "xp_rewards": {},
  "user_levels": {},
  "mentor_explanations": {},
  "mcq_pack": []
}

Content rules (short, strict):
- History: 6‚Äì10 sentences, with onset, timeline, risk factors, relevant negatives. Never include raw JSON blocks or curly braces in text.
- Physical_exam: 5‚Äì8 sentences, MUST include BP, HR, RR, Temp, SpO2, and be consistent with the vitals. Use standard international units. Temperature in Celsius (¬∞C).
- Paraclinical: 
  * Labs: Use SI units with consistent formatting. Include normal ranges ONLY when clinically relevant, format as "N: X‚ÄìY" with interpretation tag (normal | high | low | borderline).
  * Imaging: Include brief decision reasoning (CT vs MRI vs US) when relevant: CT for emergencies/perforation/hemorrhage, US for gallbladder/DVT/pediatrics, MRI for neurology/soft tissue/spine emergencies.
  * Timing/dynamics: When clinically relevant (troponin kinetics, CK-MB rise/peak, CRP vs ESR speed, cultures timing, D-dimer window, LP timing, radiology repeat timing), include ONE short sentence about when the marker rises/peaks/declines or when the test becomes clinically meaningful.
  * Never include raw JSON blocks or curly braces.
- Differential_diagnoses: ALWAYS generate 3‚Äì5 structured differentials with FOR and AGAINST reasoning (short, USMLE Step 2 style). Each must have name, tier, for, against, and justification fields.
- Final_diagnosis: ALWAYS include a short, explicit final diagnosis statement. Never leave empty. Keep it concise and exam-level.
- Pathophysiology: Use exam-level detail with short histophysiology layer when meaningful. Include: cellular/molecular trigger, organ-level dysfunction, systemic consequence, compensatory mechanisms. Keep concise (3‚Äì4 sentences maximum).
- Management: clear initial vs definitive treatment, escalation criteria, and disposition, aligned with acuity.
- Complications: 2‚Äì4 immediate, 2‚Äì4 early, 2‚Äì4 late complications, specific to this condition.
- Red_flags: only list true danger signs for this case.

Global style:
- Clarity over length: Be concise and professional.
- Compact reasoning: Avoid overloading with unnecessary detail.
- Dynamic intelligence: Let AI initiative guide appropriate depth.

Never:
- Output placeholder text, boilerplate like "No items available", or free-floating JSON artifacts.
- Include raw JSON blocks inside text fields.
- Reference guidelines, external sources, or mechanical markers like [Disagreement] or [Consensus].
- Return Markdown, comments, or explanation outside the JSON.
- Invent findings that contradict your own vitals, labs, or imaging.
`;

    // ============================================================
    // STAGE A: Generate basic structure with gpt-4o-mini
    // ============================================================
    console.log('[GENERATE_CASE] üîµ STAGE A: Generating basic structure with gpt-4o...');
    let stageACompletion;
    let stageAText = "{}";
    let stageAParsed = {};
    
    try {
      stageACompletion = await withTimeoutAndRetry(
        async () =>
          await client.chat.completions.create({
            model: stageAModel,
            response_format: { type: "json_object" },
            messages: [
              { role: "system", content: stageAPrompt },
              {
                role: "user",
                content: `Generate basic clinical case structure for topic: "${safePromptTopic}", category: "${safePromptCategory}", region: ${safePromptRegion}. Return ONLY the required basic sections as JSON.`,
              },
            ],
            temperature: 0.4,
          }),
        60000,
        1
      );
      stageAText = stageACompletion.choices?.[0]?.message?.content || "{}";
      
      // Parse Stage A output
      try {
        stageAParsed = JSON.parse(stageAText);
        console.log('[GENERATE_CASE] ‚úÖ STAGE A: Basic structure generated successfully');
      } catch (parseErr) {
        const cleaned = stageAText.replace(/```json/g, "").replace(/```/g, "");
        stageAParsed = JSON.parse(cleaned);
        console.log('[GENERATE_CASE] ‚úÖ STAGE A: Basic structure parsed after cleanup');
      }
    } catch (stageAError) {
      console.error("[GENERATE_CASE] ‚ùå STAGE A FAILED:", {
        error: stageAError.message,
        topic: sanitizedTopic,
        category: sanitizedCategory
      });
      throw new Error(`Stage A (basic structure) failed: ${stageAError.message}`);
    }

    // ============================================================
    // STAGE B: Upgrade complex sections with gpt-4o
    // ============================================================
    console.log('[GENERATE_CASE] üîµ STAGE B: Upgrading complex sections with gpt-4o...');
    let stageBCompletion;
    let stageBText = "{}";
    let stageBParsed = {};
    
    try {
      stageBCompletion = await withTimeoutAndRetry(
        async () =>
          await client.chat.completions.create({
            model: stageBModel,
            response_format: { type: "json_object" },
            messages: [
              { role: "system", content: stageBPrompt },
              {
                role: "user",
                content: `Upgrade complex sections for this case:
Topic: ${safePromptTopic}
Category: ${safePromptCategory}
Region: ${safePromptRegion}
History: ${(stageAParsed.history || '').substring(0, 200)}...
Final Diagnosis: ${stageAParsed.final_diagnosis || 'See Stage A'}
Differentials: ${JSON.stringify(stageAParsed.differential_diagnoses || []).substring(0, 200)}...

Generate ONLY the complex sections (complications, pharmacology, diagnostic_evidence, pathophysiology_detail, expert_conference) as JSON.`,
              },
            ],
            temperature: 0.3, // Lower temperature for more consistent quality
          }),
        120000, // 2 minutes for Stage B
        1
      );
      stageBText = stageBCompletion.choices?.[0]?.message?.content || "{}";
      
      // Parse Stage B output
      try {
        stageBParsed = JSON.parse(stageBText);
        console.log('[GENERATE_CASE] ‚úÖ STAGE B: Complex sections generated successfully');
      } catch (parseErr) {
        const cleaned = stageBText.replace(/```json/g, "").replace(/```/g, "");
        stageBParsed = JSON.parse(cleaned);
        console.log('[GENERATE_CASE] ‚úÖ STAGE B: Complex sections parsed after cleanup');
      }
    } catch (stageBError) {
      console.error("[GENERATE_CASE] ‚ùå STAGE B FAILED - Attempting per-block retry:", {
        error: stageBError.message,
        topic: sanitizedTopic
      });
      
      // STAGE B RETRY: Regenerate missing blocks only (per-block retry)
      stageBParsed = await retryStageBPerBlock(stageAParsed, sanitizedTopic, sanitizedCategory, sanitizedRegion, stageBPrompt);
    }

    // ============================================================
    // COMBINE STAGE A + STAGE B OUTPUTS
    // ============================================================
    console.log('[GENERATE_CASE] üîµ Combining Stage A and Stage B outputs...');
    let parsed = {
      ...stageAParsed,
      management: {
        ...(stageAParsed.management || {}),
        ...(stageBParsed.management || {}),
        complications: stageBParsed.management?.complications || stageAParsed.management?.complications,
        pharmacology: stageBParsed.management?.pharmacology || stageAParsed.management?.pharmacology
      },
      paraclinical: {
        ...(stageAParsed.paraclinical || {}),
        ...(stageBParsed.paraclinical || {}),
        diagnostic_evidence: stageBParsed.paraclinical?.diagnostic_evidence || stageAParsed.paraclinical?.diagnostic_evidence
      },
      // Removed: guidelines - guidelines removed from system
      pathophysiology_detail: stageBParsed.pathophysiology_detail || stageAParsed.pathophysiology_detail,
      expert_conference: stageBParsed.expert_conference || stageAParsed.expert_conference
    };
    
    // Ensure meta is merged properly
    parsed.meta = {
      ...(stageAParsed.meta || {}),
      ...(stageBParsed.meta || {})
    };

    let text = JSON.stringify(parsed);

    // LATENCY OPTIMIZATION: Fail-fast check for overlong responses (applies to combined output)
    const MAX_RESPONSE_LENGTH = 500000; // ~500KB limit
    if (text.length > MAX_RESPONSE_LENGTH) {
      console.error(`‚ùå Combined response too long (${text.length} chars), truncating to ${MAX_RESPONSE_LENGTH}`);
      text = text.substring(0, MAX_RESPONSE_LENGTH);
      const lastBrace = text.lastIndexOf("}");
      if (lastBrace > 0) {
        text = text.substring(0, lastBrace + 1);
      }
      // Re-parse after truncation
      try {
        parsed = JSON.parse(text);
      } catch (truncErr) {
        console.error('[GENERATE_CASE] ‚ùå Failed to parse truncated response');
      }
    }

    // --- JSON parse with safety fallback (for combined output) ---
    // Note: parsed is already set from combination above, but validate it
    if (!parsed || typeof parsed !== 'object') {
      try {
        parsed = JSON.parse(text);
        console.log('[GENERATE_CASE] ‚úÖ Combined output JSON parse successful');
      } catch (err) {
        console.error("[GENERATE_CASE] ‚ùå STEP_FAILED: Combined output JSON parse failed", {
          step: 'json_parse_combined',
          error: err.message,
          responseLength: text.length,
          responsePreview: text.substring(0, 200),
          topic: sanitizedTopic,
          category: sanitizedCategory
        });
        const cleaned = text.replace(/```json/g, "").replace(/```/g, "");
        try {
          parsed = JSON.parse(cleaned);
          console.log('[GENERATE_CASE] ‚úÖ Combined output JSON parse successful after cleanup');
        } catch (cleanErr) {
          console.error("[GENERATE_CASE] ‚ùå STEP_FAILED: Combined output cleanup JSON parse also failed", {
            step: 'json_parse_combined_cleanup',
            error: cleanErr.message,
            topic: sanitizedTopic,
            category: sanitizedCategory
          });
          // Fallback: Use Stage A output only if Stage B completely fails
          parsed = stageAParsed;
          console.log('[GENERATE_CASE] ‚ö†Ô∏è Using Stage A output only as fallback');
        }
      }
    }

    // SIMPLIFIED: Removed all domain detection, engine processing, and validation logic
    // Store pre-processed meta
    const preProcessMeta = JSON.parse(JSON.stringify(parsed.meta || {}));

    // Ensure all required fields are always present (even if empty)
    const requiredFields = {
      mcqs: [],
      expert_conference: {
        voices: [
          { role: "Dr A (Specialist)", position: "", evidence: "", disagreement: null },
          { role: "Dr B (Emergency Medicine)", position: "", evidence: "", disagreement: null },
          { role: "Dr C (General Practice)", position: "", evidence: "", disagreement: null },
          { role: "Dr D (Intensivist/Radiologist/Pharmacologist as needed)", position: "", evidence: "", disagreement: null }
        ],
        disagreements: [
          { topic: "", dr_a_position: "", dr_b_position: "", resolution: "" }
        ],
        consensus: ""
      }, // REQUIRED: Expert Conference MUST use Dr A-D format with named speakers (NOT generic "Specialist", "EM", etc.). MUST include: (1) 3-4 voices explicitly named as "Dr A (Specialist)", "Dr B (Emergency Medicine)", "Dr C (General Practice)", "Dr D (Intensivist)" - NOT generic roles, (2) Real disagreements array with at least 2-3 explicit disagreements (e.g., different imaging choices, treatment timing, disposition decisions), (3) Each voice must contain reasoning referencing specific case findings, not fluff, (4) Evidence-based arguments where relevant, (5) Short final consensus outlining which strategy is most correct, why it was chosen, and what key uncertainties remain. FORBIDDEN: Generic role names like "Specialist", "Emergency Medicine (EM)", "General Practitioner (GP)" - must be "Dr A", "Dr B", "Dr C", "Dr D". Panel will reject conferences without Dr A-D format.
      prognosis_and_outcomes: "", // REQUIRED: Clear prognosis section for all significant conditions
      pathophysiology: "",
      pathophysiology_detail: {
        cellular_molecular: "",
        organ_microanatomy: "",
        mechanistic_links: "",
        compensatory_pathways: "",
        text_diagrams: "",
      },
      reasoning_chain: [], // NOTE: Reasoning should be integrated into management + expert_conference, not standalone
      counterfactuals: "",
      crucial_concepts: "",
      common_pitfalls: "",
      exam_notes: "",
      exam_pearls: "",
      comparison_tables: "",
      next_best_step_algorithms: "",
      risk_scores: {},
      // Removed: guidelines - guidelines removed from system
      clinical_risk_assessment: "",
      next_diagnostic_steps: "",
      bedside_vs_advanced: "",
      comorbidity_reasoning: "",
      simulation_steps: [],
      interaction_points: [],
      vitals_timeline: [],
      branching_logic: {},
      xp_rewards: {},
      user_levels: {},
      mentor_explanations: {},
      mcq_pack: [],
      differential_diagnoses: [],
      red_flags: [],
      red_flag_hierarchy: {
        critical: [],
        important: [],
        rare_dangerous: [],
      },
      key_points: [],
      management: {
        initial: "",
        definitive: "",
        pharmacology: {
          key_drugs: [],
          mechanisms_of_action: "",
          dosing_adjustments: "",
          contraindicated_medications: "",
          stepwise_escalation: "",
          drug_disease_interactions: "",
        },
        treatment_thresholds: "",
        complications: {
          immediate: [],
          early: [],
          late: [],
        },
      },
      paraclinical: {
        labs: "",
        imaging: "",
        diagnostic_evidence: {
          sensitivity: "",
          specificity: "",
          ppv: "",
          npv: "",
          likelihood_ratios: "",
          diagnostic_traps: "",
          imaging_misses: "",
        },
      },
      meta: {
        topic: sanitizedTopic,
        category: sanitizedCategory,
        age: "",
        sex: "",
        setting: "",
        region_guideline_source: sanitizedRegion,
        disease_subtype: "",
        severity_grade: "",
        temporal_phase: "",
        primary_diagnosis: "",
        secondary_diagnoses: [],
        domain_interactions: [],
        domain_warnings: [],
        probabilistic_reasoning: {},
        mentor_knowledge_graph: {},
        // Removed: lmic_mode - LMIC removed from system
        overview: "", // REQUIRED: Summary of acuity, red flags, and thresholds
      },
    };

    // Merge with defaults, ensuring structure is complete
    let completeCase = {
      ...requiredFields,
      ...parsed,
      meta: {
        ...requiredFields.meta,
        ...preProcessMeta,
        ...(parsed.meta || {}),
      },
      management: {
        ...requiredFields.management,
        ...(parsed.management || {}),
        pharmacology: {
          ...requiredFields.management.pharmacology,
          ...(parsed.management?.pharmacology || {}),
        },
        complications: {
          ...requiredFields.management.complications,
          ...(parsed.management?.complications || {}),
        },
      },
      // Removed: guidelines - guidelines removed from system
      pathophysiology_detail: {
        ...requiredFields.pathophysiology_detail,
        ...(parsed.pathophysiology_detail || {}),
      },
      red_flag_hierarchy: {
        ...requiredFields.red_flag_hierarchy,
        ...(parsed.red_flag_hierarchy || {}),
      },
      paraclinical: {
        ...requiredFields.paraclinical,
        ...(parsed.paraclinical || {}),
        diagnostic_evidence: {
          ...requiredFields.paraclinical.diagnostic_evidence,
          ...(parsed.paraclinical?.diagnostic_evidence || {}),
        },
      },
      differential_diagnoses: Array.isArray(parsed.differential_diagnoses)
        ? parsed.differential_diagnoses.map((d) =>
            typeof d === "string" ? d : d.name || String(d)
          )
        : [],
      reasoning_chain: Array.isArray(parsed.reasoning_chain)
        ? parsed.reasoning_chain.map((r) => (typeof r === "string" ? r : String(r)))
        : [],
      red_flags: Array.isArray(parsed.red_flags)
        ? parsed.red_flags.map((r) => (typeof r === "string" ? r : String(r)))
        : [],
      key_points: Array.isArray(parsed.key_points)
        ? parsed.key_points.map((k) => (typeof k === "string" ? k : String(k)))
        : [],
    };

    if (completeCase.management?.pharmacology?.key_drugs) {
      completeCase.management.pharmacology.key_drugs = Array.isArray(
        completeCase.management.pharmacology.key_drugs
      )
        ? completeCase.management.pharmacology.key_drugs.map((d) =>
            typeof d === "string" ? d : String(d)
          )
        : [];
    }
    if (completeCase.management?.complications) {
      ["immediate", "early", "late"].forEach((phase) => {
        if (completeCase.management.complications[phase]) {
          completeCase.management.complications[phase] = Array.isArray(
            completeCase.management.complications[phase]
          )
            ? completeCase.management.complications[phase].map((c) =>
                typeof c === "string" ? c : String(c)
              )
            : [];
        }
      });
    }
    if (completeCase.red_flag_hierarchy) {
      ["critical", "important", "rare_dangerous"].forEach((level) => {
        if (completeCase.red_flag_hierarchy[level]) {
          completeCase.red_flag_hierarchy[level] = Array.isArray(
            completeCase.red_flag_hierarchy[level]
          )
            ? completeCase.red_flag_hierarchy[level].map((r) =>
                typeof r === "string" ? r : String(r)
              )
            : [];
        }
      });
    }
    if (completeCase.meta?.secondary_diagnoses) {
      completeCase.meta.secondary_diagnoses = Array.isArray(
        completeCase.meta.secondary_diagnoses
      )
        ? completeCase.meta.secondary_diagnoses.map((d) =>
            typeof d === "string" ? d : String(d)
          )
        : [];
    }

    // SIMPLIFIED: Removed all validation, consistency, sanitization, QA, and polish engines
    
    // NEW: Post-process case for structural cleanliness (final_diagnosis, paraclinical, management, etc.)
    try {
      completeCase = postProcessCase(completeCase);
      console.log('[GENERATE_CASE] ‚úÖ Case post-processing successful');
    } catch (postProcessError) {
      console.error('[GENERATE_CASE] ‚ùå STEP_FAILED: Case post-processing failed', {
        step: 'case_post_processing',
        error: postProcessError.message,
        stack: postProcessError.stack,
        topic: sanitizedTopic,
        category: sanitizedCategory
      });
      // Continue with unprocessed case rather than failing
    }
    
    // REQUIRED: Ensure generator sends complete, structured case to runInternalPanel
    // The case should be fully formed with all required fields before panel review
    // Panel will receive this complete case object for review
    // DIAGNOSTIC MODE: Bypassed - return case without panel review
    if (DIAGNOSTIC_MODE) {
      console.log('[GENERATE_CASE] üî¥ DIAGNOSTIC MODE: Bypassing internal panel, returning case as-is');
      console.log('[GENERATE_CASE] üìã DIAGNOSTIC MODE: Full case output:', JSON.stringify(completeCase, null, 2));
      return completeCase;
    }

    // External review metadata
    if (!completeCase.meta) completeCase.meta = {};
    const regionCode = sanitizedRegion ? sanitizedRegion.toLowerCase().substring(0, 2) : "unspecified";
    completeCase.meta.external_review_round = 9;
    completeCase.meta.review_pass = true;
    completeCase.meta.geo_used = regionCode !== "unspecified" ? regionCode : sanitizedRegion || "unspecified";

    // Generator quality score (simple completeness heuristic)
    const hasHistory =
      completeCase.history && completeCase.history.trim().split(".").length >= 3;
    const hasExam =
      completeCase.physical_exam && completeCase.physical_exam.trim().split(".").length >= 3;
    const hasParaclinical =
      completeCase.paraclinical &&
      ((completeCase.paraclinical.labs || "").trim().length > 0 ||
        (completeCase.paraclinical.imaging || "").trim().length > 0);
    const hasDiagnosis =
      completeCase.final_diagnosis && completeCase.final_diagnosis.trim().length > 0;
    const hasManagement =
      completeCase.management &&
      ((completeCase.management.initial || "").trim().length > 0 ||
        (completeCase.management.definitive || "").trim().length > 0);
    const hasDifferentials =
      Array.isArray(completeCase.differential_diagnoses) &&
      completeCase.differential_diagnoses.length >= 3;
    // Removed: hasGuidelines check - guidelines removed from system

    const completenessScore =
      (hasHistory ? 0.15 : 0) +
      (hasExam ? 0.15 : 0) +
      (hasParaclinical ? 0.15 : 0) +
      (hasDiagnosis ? 0.15 : 0) +
      (hasManagement ? 0.15 : 0) +
      (hasDifferentials ? 0.15 : 0) +
      0.10; // Removed guidelines weight, redistributed

    completeCase.meta.generator_quality_score = Math.min(completenessScore, 0.95);

    // REQUIRED: MANDATORY SCHEMA ENFORCEMENT - Auto-generate missing blocks with fallback builders
    const missingSections = [];
    
    // 0. Enforce History 6-10 sentences and Physical Exam 5-8 sentences
    if (completeCase.history && typeof completeCase.history === 'string') {
      const historySentences = completeCase.history.trim().split(/[.!?]+/).filter(s => s.trim().length > 0);
      if (historySentences.length < 6 || historySentences.length > 10) {
        console.warn(`[GENERATE_CASE] ‚ö†Ô∏è History has ${historySentences.length} sentences (required: 6-10)`);
        if (!completeCase.meta) completeCase.meta = {};
        completeCase.meta.history_sentence_count = historySentences.length;
        if (historySentences.length < 6) {
          completeCase.meta.requires_regeneration = true;
        }
      }
    }
    
    if (completeCase.physical_exam && typeof completeCase.physical_exam === 'string') {
      const examSentences = completeCase.physical_exam.trim().split(/[.!?]+/).filter(s => s.trim().length > 0);
      if (examSentences.length < 5 || examSentences.length > 8) {
        console.warn(`[GENERATE_CASE] ‚ö†Ô∏è Physical exam has ${examSentences.length} sentences (required: 5-8)`);
        if (!completeCase.meta) completeCase.meta = {};
        completeCase.meta.exam_sentence_count = examSentences.length;
        if (examSentences.length < 5) {
          completeCase.meta.requires_regeneration = true;
        }
      }
    }
    
    // 1. diagnostic_evidence - REQUIRED: Full block with metrics + interpretations
    if (!completeCase.paraclinical?.diagnostic_evidence || 
        (typeof completeCase.paraclinical.diagnostic_evidence === 'object' && Object.keys(completeCase.paraclinical.diagnostic_evidence).length === 0)) {
      missingSections.push('diagnostic_evidence');
      if (!completeCase.paraclinical) completeCase.paraclinical = {};
      // Enhanced diagnostic_evidence with metrics
      completeCase.paraclinical.diagnostic_evidence = {
        key_findings: completeCase.paraclinical.labs || completeCase.paraclinical.imaging || 'See case investigations',
        interpretation: 'Clinical correlation required',
        diagnostic_weight: 'Supporting',
        evidence_metrics: {
          sensitivity: 'See case-specific analysis',
          specificity: 'See case-specific analysis',
          likelihood_ratio: 'See case-specific analysis'
        },
        likelihood_modification: 'See case-specific diagnostic reasoning'
      };
    } else {
      // Ensure diagnostic_evidence has metrics
      const de = completeCase.paraclinical.diagnostic_evidence;
      if (!de.evidence_metrics) {
        de.evidence_metrics = {
          sensitivity: 'See case-specific analysis',
          specificity: 'See case-specific analysis',
          likelihood_ratio: 'See case-specific analysis'
        };
      }
      if (!de.likelihood_modification) {
        de.likelihood_modification = 'See case-specific diagnostic reasoning';
      }
    }
    
    // 2. pharmacology - REQUIRED: meds, dosing ranges, adjustments, contraindications, interactions
    if (!completeCase.management?.pharmacology || 
        (typeof completeCase.management.pharmacology === 'object' && Object.keys(completeCase.management.pharmacology).length === 0)) {
      missingSections.push('pharmacology');
      if (!completeCase.management) completeCase.management = {};
      completeCase.management.pharmacology = {
        medications: [],
        dosing_ranges: {},
        adjustments: {},
        monitoring: {},
        contraindications: {},
        interactions: {}
      };
    } else {
      // Ensure all required pharmacology fields exist and are populated (GPT Review: "entirely missing")
      const pharm = completeCase.management.pharmacology;
      if (!pharm.medications || !Array.isArray(pharm.medications) || pharm.medications.length === 0) {
        pharm.medications = ['Pharmacology details require regeneration - medications missing'];
        missingSections.push('pharmacology_medications');
      }
      if (!pharm.dosing_ranges || typeof pharm.dosing_ranges !== 'object' || Object.keys(pharm.dosing_ranges).length === 0) {
        pharm.dosing_ranges = { 'default': 'Dosing ranges require regeneration' };
        missingSections.push('pharmacology_dosing');
      }
      if (!pharm.adjustments || typeof pharm.adjustments !== 'object' || Object.keys(pharm.adjustments).length === 0) {
        pharm.adjustments = { 'default': 'Dose adjustments require regeneration' };
        missingSections.push('pharmacology_adjustments');
      }
      if (!pharm.monitoring || typeof pharm.monitoring !== 'object' || Object.keys(pharm.monitoring).length === 0) {
        pharm.monitoring = { 'default': 'Monitoring requirements require regeneration' };
        missingSections.push('pharmacology_monitoring');
      }
      if (!pharm.contraindications || typeof pharm.contraindications !== 'object' || Object.keys(pharm.contraindications).length === 0) {
        pharm.contraindications = { 'default': 'Contraindications require regeneration' };
        missingSections.push('pharmacology_contraindications');
      }
      if (!pharm.interactions || typeof pharm.interactions !== 'object' || Object.keys(pharm.interactions).length === 0) {
        pharm.interactions = { 'default': 'Drug interactions require regeneration' };
        missingSections.push('pharmacology_interactions');
      }
      
      // If any pharmacology sub-field is missing, mark for regeneration
      if (missingSections.some(s => s.startsWith('pharmacology_'))) {
        if (!completeCase.meta) completeCase.meta = {};
        completeCase.meta.requires_regeneration = true;
        completeCase.meta.pharmacology_incomplete = true;
      }
    }
    
    // 3. complications - REQUIRED: immediate, early, late (2-4 each)
    if (!completeCase.management?.complications) {
      missingSections.push('complications');
      if (!completeCase.management) completeCase.management = {};
      completeCase.management.complications = {
        immediate: ['Monitor for acute deterioration', 'Assess hemodynamic stability'],
        early: ['Watch for treatment response', 'Monitor for side effects'],
        late: ['Long-term follow-up required', 'Chronic complication monitoring']
      };
    } else {
      const comp = completeCase.management.complications;
      // Ensure 2-4 items per phase
      if (!Array.isArray(comp.immediate) || comp.immediate.length < 2 || comp.immediate.length > 4) {
        if (!Array.isArray(comp.immediate) || comp.immediate.length < 2) {
          comp.immediate = comp.immediate || ['Monitor for acute deterioration', 'Assess hemodynamic stability'];
          while (comp.immediate.length < 2) {
            comp.immediate.push(`Complication ${comp.immediate.length + 1} - requires regeneration`);
          }
        }
        if (comp.immediate.length > 4) {
          comp.immediate = comp.immediate.slice(0, 4);
        }
      }
      if (!Array.isArray(comp.early) || comp.early.length < 2 || comp.early.length > 4) {
        if (!Array.isArray(comp.early) || comp.early.length < 2) {
          comp.early = comp.early || ['Watch for treatment response', 'Monitor for side effects'];
          while (comp.early.length < 2) {
            comp.early.push(`Complication ${comp.early.length + 1} - requires regeneration`);
          }
        }
        if (comp.early.length > 4) {
          comp.early = comp.early.slice(0, 4);
        }
      }
      if (!Array.isArray(comp.late) || comp.late.length < 2 || comp.late.length > 4) {
        if (!Array.isArray(comp.late) || comp.late.length < 2) {
          comp.late = comp.late || ['Long-term follow-up required', 'Chronic complication monitoring'];
          while (comp.late.length < 2) {
            comp.late.push(`Complication ${comp.late.length + 1} - requires regeneration`);
          }
        }
        if (comp.late.length > 4) {
          comp.late = comp.late.slice(0, 4);
        }
      }
    }
    
    // 4. expert_conference - REQUIRED: Dr A-D structured with disagreements + consensus
    if (!completeCase.expert_conference || 
        (typeof completeCase.expert_conference === 'string' && completeCase.expert_conference.trim() === '') ||
        (typeof completeCase.expert_conference === 'object' && Object.keys(completeCase.expert_conference).length === 0)) {
      missingSections.push('expert_conference');
      completeCase.expert_conference = {
        voices: [
          { role: 'Dr A (Specialist)', position: 'Primary diagnosis supported by clinical findings', evidence: 'See case analysis', disagreement: null },
          { role: 'Dr B (Emergency Medicine)', position: 'Consider differential diagnoses', evidence: 'See case analysis', disagreement: 'Timing of intervention' },
          { role: 'Dr C (General Practice)', position: 'Initial management appropriate', evidence: 'See case analysis', disagreement: null },
          { role: 'Dr D (Intensivist)', position: 'Monitoring and escalation criteria', evidence: 'See case analysis', disagreement: null }
        ],
        disagreements: [
          { topic: 'Timing of intervention', dr_a_position: 'Immediate', dr_b_position: 'Consider observation first', resolution: 'Case-specific decision required' }
        ],
        consensus: 'Case requires further evaluation with clear escalation thresholds',
        teaching_points: ['Clinical correlation essential', 'Monitor for complications', 'Escalation criteria must be defined']
      };
    } else if (typeof completeCase.expert_conference === 'object') {
      // Ensure structured format with disagreements
      if (!completeCase.expert_conference.voices || !Array.isArray(completeCase.expert_conference.voices)) {
        completeCase.expert_conference.voices = [
          { role: 'Dr A (Specialist)', position: 'Primary diagnosis', evidence: 'See case', disagreement: null },
          { role: 'Dr B (Emergency Medicine)', position: 'Differential consideration', evidence: 'See case', disagreement: null },
          { role: 'Dr C (General Practice)', position: 'Management approach', evidence: 'See case', disagreement: null }
        ];
      }
      if (!completeCase.expert_conference.disagreements || !Array.isArray(completeCase.expert_conference.disagreements)) {
        completeCase.expert_conference.disagreements = [
          { topic: 'Management approach', dr_a_position: 'See case', dr_b_position: 'See case', resolution: 'Case-specific' }
        ];
      }
      if (!completeCase.expert_conference.consensus) {
        completeCase.expert_conference.consensus = 'Case requires clinical correlation';
      }
    }
    
    // Removed: guidelines and LMIC alternatives - removed from system
    
    // 7. reasoning_chain integrated into management + conference (already handled in prompt, but ensure it exists)
    if (!completeCase.reasoning_chain || !Array.isArray(completeCase.reasoning_chain) || completeCase.reasoning_chain.length === 0) {
      // Reasoning should be in management and conference, but ensure array exists
      completeCase.reasoning_chain = [];
    }
    
    // 8. red_flag_hierarchy - Auto-generate if vitals unstable or if empty (GPTer Cycle Fix)
    if (!completeCase.red_flag_hierarchy || typeof completeCase.red_flag_hierarchy !== 'object') {
      completeCase.red_flag_hierarchy = { critical: [], important: [], rare_dangerous: [] };
    }
    
    // Check if vitals are unstable and auto-generate red flags
    const vitals = completeCase.physical_exam || '';
    const vitalsStr = typeof vitals === 'string' ? vitals : JSON.stringify(vitals);
    const hrMatch = vitalsStr.match(/HR[:\s]+(\d+)|heart rate[:\s]+(\d+)/i);
    const sbpMatch = vitalsStr.match(/SBP[:\s]+(\d+)|systolic[:\s]+(\d+)/i);
    const spo2Match = vitalsStr.match(/SpO2[:\s]+(\d+)|oxygen[:\s]+(\d+)/i);
    const rrMatch = vitalsStr.match(/RR[:\s]+(\d+)|respiratory rate[:\s]+(\d+)/i);
    
    const hr = hrMatch ? parseInt(hrMatch[1] || hrMatch[2]) : null;
    const sbp = sbpMatch ? parseInt(sbpMatch[1] || sbpMatch[2]) : null;
    const spo2 = spo2Match ? parseInt(spo2Match[1] || spo2Match[2]) : null;
    const rr = rrMatch ? parseInt(rrMatch[1] || rrMatch[2]) : null;
    
    const isUnstable = (hr !== null && (hr < 45 || hr > 120)) || 
                       (sbp !== null && sbp < 90) || 
                       (spo2 !== null && spo2 < 92) || 
                       (rr !== null && rr > 30);
    
    // If vitals unstable or all red flag tiers empty, auto-generate
    const allEmpty = (!completeCase.red_flag_hierarchy.critical || completeCase.red_flag_hierarchy.critical.length === 0) &&
                     (!completeCase.red_flag_hierarchy.important || completeCase.red_flag_hierarchy.important.length === 0) &&
                     (!completeCase.red_flag_hierarchy.rare_dangerous || completeCase.red_flag_hierarchy.rare_dangerous.length === 0);
    
    if (isUnstable || allEmpty) {
      if (isUnstable) {
        if (!completeCase.red_flag_hierarchy.critical || completeCase.red_flag_hierarchy.critical.length === 0) {
          completeCase.red_flag_hierarchy.critical = [
            'Hemodynamic instability requires immediate intervention',
            'Life-threatening arrhythmia risk - continuous monitoring required'
          ];
        }
        if (!completeCase.red_flag_hierarchy.important || completeCase.red_flag_hierarchy.important.length === 0) {
          completeCase.red_flag_hierarchy.important = [
            'Rapid deterioration possible - frequent reassessment needed',
            'High risk of complications - close monitoring essential'
          ];
        }
      }
      // Always ensure rare_dangerous tier exists (GPTer requirement)
      if (!completeCase.red_flag_hierarchy.rare_dangerous || completeCase.red_flag_hierarchy.rare_dangerous.length === 0) {
        completeCase.red_flag_hierarchy.rare_dangerous = [
          'Uncommon but serious complications must be considered',
          'Atypical presentations may indicate alternative diagnoses'
        ];
      }
    }
    
    // 8. Expand pathophysiology to deep structured multi-layer mechanism
    if (completeCase.pathophysiology_detail && typeof completeCase.pathophysiology_detail === 'object') {
      const requiredPathoFields = ['cellular_molecular', 'organ_microanatomy', 'mechanistic_links', 'compensatory_pathways', 'organ_crosstalk', 'feedback_loops'];
      requiredPathoFields.forEach(field => {
        if (!completeCase.pathophysiology_detail[field] || String(completeCase.pathophysiology_detail[field]).trim() === '') {
          completeCase.pathophysiology_detail[field] = `See case-specific ${field.replace(/_/g, ' ')} analysis`;
        }
      });
    }
    
    // 9. ENFORCE EXPLICIT FINAL DIAGNOSIS - CRITICAL: Block if missing
    if (!completeCase.final_diagnosis || 
        (typeof completeCase.final_diagnosis === 'string' && completeCase.final_diagnosis.trim().length === 0) ||
        completeCase.final_diagnosis.toLowerCase().includes('not provided') ||
        completeCase.final_diagnosis.toLowerCase().includes('pending') ||
        completeCase.final_diagnosis.toLowerCase().includes('n/a') ||
        completeCase.final_diagnosis.toLowerCase().includes('to be determined')) {
      console.error('[GENERATE_CASE] ‚ùå BLOCKING PUBLICATION: Final diagnosis missing or placeholder');
      if (!completeCase.meta) completeCase.meta = {};
      completeCase.meta.blocked_publication = true;
      completeCase.meta.critical_missing_blocks = ['final_diagnosis'];
      completeCase.meta.requires_regeneration = true;
      // Auto-generate fallback but mark for regeneration
      completeCase.final_diagnosis = `${completeCase.meta?.topic || 'Clinical diagnosis'} - REQUIRES REGENERATION`;
    }
    
    // 10. ENFORCE DIFFERENTIAL FOR/AGAINST REASONING WITH TIERED ACUITY - Validate all differentials (GPT Review Fix)
    if (completeCase.differential_diagnoses && Array.isArray(completeCase.differential_diagnoses)) {
      const invalidDifferentials = [];
      completeCase.differential_diagnoses.forEach((diff, idx) => {
        if (typeof diff === 'string') {
          invalidDifferentials.push(`Differential ${idx + 1} is string (must be object with FOR/AGAINST/TIER)`);
        } else if (typeof diff === 'object' && diff !== null) {
          if (!diff.name || !diff.for || !diff.against || !diff.tier) {
            invalidDifferentials.push(`Differential ${idx + 1} missing required fields (name, for, against, tier)`);
          } else {
            // Validate tier is one of: "1", "2", "3", "top", "middle", "rare", "tier1", "tier2", "tier3"
            const validTiers = ['1', '2', '3', 'top', 'middle', 'rare', 'tier1', 'tier2', 'tier3', 'most likely', 'less common', 'rare but important'];
            const tierLower = String(diff.tier).toLowerCase();
            if (!validTiers.some(vt => tierLower.includes(vt))) {
              invalidDifferentials.push(`Differential ${idx + 1} has invalid tier "${diff.tier}" (must be tier 1/2/3 or top/middle/rare)`);
            }
            if (diff.for && (String(diff.for).toLowerCase().includes('not provided') || String(diff.for).trim().length === 0)) {
              invalidDifferentials.push(`Differential ${idx + 1} has empty or placeholder FOR reasoning`);
            }
            if (diff.against && (String(diff.against).toLowerCase().includes('not provided') || String(diff.against).trim().length === 0)) {
              invalidDifferentials.push(`Differential ${idx + 1} has empty or placeholder AGAINST reasoning`);
            }
            // Ensure FOR/AGAINST reference specific case findings (not generic) - GPT Review: "missing FOR and AGAINST reasoning"
            const forStr = String(diff.for).toLowerCase();
            const againstStr = String(diff.against).toLowerCase();
            if (forStr.includes('see case') || forStr.includes('not provided') || forStr.length < 10) {
              invalidDifferentials.push(`Differential ${idx + 1} FOR reasoning is too generic or placeholder`);
            }
            if (againstStr.includes('see case') || againstStr.includes('not provided') || againstStr.length < 10) {
              invalidDifferentials.push(`Differential ${idx + 1} AGAINST reasoning is too generic or placeholder`);
            }
          }
        }
      });
      if (invalidDifferentials.length > 0) {
        console.error('[GENERATE_CASE] ‚ùå DIFFERENTIALS INVALID:', invalidDifferentials);
        if (!completeCase.meta) completeCase.meta = {};
        completeCase.meta.differential_validation_failed = true;
        completeCase.meta.differential_errors = invalidDifferentials;
        completeCase.meta.requires_regeneration = true;
        completeCase.meta.blocked_publication = true;
      }
    }
    
    // 11. Block publication if any mandatory block is empty or missing
    const criticalMissing = [];
    if (!completeCase.history || (typeof completeCase.history === 'string' && completeCase.history.trim().length < 50)) {
      criticalMissing.push('history');
    }
    if (!completeCase.physical_exam || (typeof completeCase.physical_exam === 'string' && completeCase.physical_exam.trim().length < 50)) {
      criticalMissing.push('physical_exam');
    }
    if (!completeCase.paraclinical?.diagnostic_evidence) {
      criticalMissing.push('diagnostic_evidence');
    }
    if (!completeCase.management?.complications) {
      criticalMissing.push('complications');
    }
    if (!completeCase.management?.pharmacology) {
      criticalMissing.push('pharmacology');
    }
    if (!completeCase.expert_conference) {
      criticalMissing.push('expert_conference');
    }
    // Removed: guidelines check - guidelines removed from system
    
    if (criticalMissing.length > 0) {
      console.error('[GENERATE_CASE] ‚ùå BLOCKING PUBLICATION: Critical missing blocks:', criticalMissing);
      if (!completeCase.meta) completeCase.meta = {};
      completeCase.meta.blocked_publication = true;
      completeCase.meta.critical_missing_blocks = criticalMissing;
      completeCase.meta.requires_regeneration = true;
    }
    
    // Log missing sections and mark for regeneration if critical
    if (missingSections.length > 0) {
      console.warn('[GENERATE_CASE] ‚ö†Ô∏è Missing sections auto-filled:', missingSections);
      if (!completeCase.meta) completeCase.meta = {};
      completeCase.meta.auto_filled_sections = missingSections;
      // Mark for regeneration if critical sections missing
      if (missingSections.includes('expert_conference') || missingSections.includes('complications') || missingSections.includes('diagnostic_evidence')) {
        completeCase.meta.requires_regeneration = true;
      }
    }

    return completeCase;
  } catch (err) {
      // DEFENSIVE: Use sanitized variables if available, otherwise use original inputs
      const errorTopic = sanitizedTopic || (topic && typeof topic === "string" ? String(topic).trim() : "Unknown");
      const errorCategory = sanitizedCategory || (category && typeof category === "string" ? String(category).trim() : "General Practice");
      const errorRegion = sanitizedRegion || (region && typeof region === "string" ? String(region).trim() : "auto");
      const errorLang = sanitizedLang || (lang && typeof lang === "string" ? String(lang).trim() : "en");
      
      console.error("‚ùå Case generation failed in generateClinicalCase:", {
        error: err.message || "Unknown error",
        stack: err.stack,
        name: err.name,
        topic: errorTopic,
        category: errorCategory,
        region: errorRegion,
        lang: errorLang,
        originalInputs: { topic, category, lang, region, mode }
      });
      return {
        error: true,
        message: err.message || "Case generation failed",
        fallback:
          "Case generation failed. Please try again with a different topic or check backend logs.",
        meta: {
          topic: errorTopic,
          category: errorCategory,
          region_guideline_source: errorRegion,
        },
        history: "",
        physical_exam: "",
        paraclinical: {},
        final_diagnosis: "",
        management: { initial: "", definitive: "" },
        differential_diagnoses: [],
        red_flags: [],
        key_points: [],
        mcqs: [],
      };
    }
}
