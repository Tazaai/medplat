name: Copilot Bot â€” Auto Rerun & Self-Heal

on:
  workflow_run:
    types: [completed]

permissions:
  actions: write
  checks: write
  issues: write
  contents: read

jobs:
  auto-rerun:
    runs-on: ubuntu-latest
    steps:
      - name: Check workflow run conclusion
        uses: actions/github-script@v6
        id: rerun-check
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const run = context.payload.workflow_run;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            if (!run) {
              core.info('No workflow_run payload. Exiting.');
              return { should_rerun: false };
            }
            core.info(`Workflow run ${run.id} for workflow ${run.name} concluded with ${run.conclusion}`);

            // Only auto-rerun selected workflows to avoid noise. Update this list if you add more.
            const allowed = [
              'Deploy MedPlat (Local-First â†’ Cloud Run)',
              'CI checks â€” backend tests + frontend build'
            ];
            if (!allowed.includes(run.name)) {
              core.info(`Workflow ${run.name} not in allowed list; skipping auto-rerun.`);
              return { should_rerun: false };
            }

            if (run.conclusion === 'success') {
              core.info('Run succeeded; check for any open investigation issues to close.');
              // Find open issues labeled 'auto-rerun' that reference this head_sha and close them
              let closedIssues = [];
              try {
                const issuesResp = await github.rest.issues.listForRepo({ owner, repo, labels: 'auto-rerun', state: 'open', per_page: 100 });
                const issues = issuesResp.data || [];
                for (const issue of issues) {
                  const body = issue.body || '';
                  const title = issue.title || '';
                  if (body.includes(run.head_sha) || title.includes(run.head_sha)) {
                    core.info(`Closing issue #${issue.number} (${issue.title}) for head ${run.head_sha}`);
                    await github.rest.issues.createComment({ owner, repo, issue_number: issue.number, body: 'âœ… Auto-rerun succeeded; closing this investigation issue.' });
                    await github.rest.issues.update({ owner, repo, issue_number: issue.number, state: 'closed' });
                    closedIssues.push(issue.number);
                  }
                }
              } catch (e) {
                core.warning('Failed to query/close issues: ' + e.message);
              }

              // If we closed anything, write a small audit note to the workspace and return its name so a later step can upload it
              if (closedIssues.length > 0) {
                try {
                  const fs = require('fs');
                  const ts = new Date().toISOString();
                  const filename = `copilot-bot-close-${Date.now()}.md`;
                  const contents = [
                    `# Copilot Bot Auto-Close Audit`,
                    ``,
                    `- timestamp: ${ts}`,
                    `- workflow_name: ${run.name}`,
                    `- workflow_run_id: ${run.id}`,
                    `- head_sha: ${run.head_sha}`,
                    `- closed_issues: ${closedIssues.join(', ')}`,
                    ``,
                    `This file was generated by copilot-bot.yml to record automatic issue closure activity.`
                  ].join('\n');
                  fs.writeFileSync(filename, contents, 'utf8');
                  core.info(`Wrote auto-close audit ${filename}`);
                  return { should_rerun: false, closed: true, close_filename: filename };
                } catch (e) {
                  core.warning('Failed to write auto-close audit file: ' + e.message);
                  return { should_rerun: false, closed: false, close_filename: '' };
                }
              }

              return { should_rerun: false, closed: false, close_filename: '' };
            }

            // Determine how many runs exist for this workflow + head_sha
            const workflow_id = run.workflow_id;
            const head_sha = run.head_sha;
            core.info(`Checking prior runs for workflow_id=${workflow_id} head_sha=${head_sha}`);

            const runsResp = await github.rest.actions.listWorkflowRunsForRepo({ owner, repo, per_page: 100 });
            const runs = runsResp.data.workflow_runs.filter(r => r.workflow_id === workflow_id && r.head_sha === head_sha);
            const attempts = runs.length;
            core.info(`Found ${attempts} runs for the same head_sha`);

            const maxAttempts = parseInt(process.env.COPILOT_BOT_MAX_ATTEMPTS || '3', 10);
            if (attempts >= maxAttempts) {
              core.info(`Attempts (${attempts}) >= maxAttempts (${maxAttempts}) -> not rerunning`);
              // Prepare an auto-issue payload so the workflow can create an investigation ticket
              const title = `âš ï¸ Auto-Rerun failed: ${run.name} (${head_sha})`;
              const body = `Auto-rerun attempted ${attempts} times for workflow **${run.name}** on commit ${head_sha}.
\n- Workflow run id: ${run.id}\n- Head SHA: ${head_sha}\n- Attempts: ${attempts} (max ${maxAttempts})\n\nPlease review the CI logs and investigate the failure.\n\nContext: ${run.html_url || 'n/a'}`;
              return { should_rerun: false, attempts, open_issue: true, issue_title: title, issue_body: body };
            }

            // compute delay (ms) with jitter up to 1000ms
            const baseDelaySec = Math.pow(2, attempts); // 2^attempts seconds
            const jitter = Math.floor(Math.random() * 1000); // 0-999ms
            const delayMs = (baseDelaySec * 1000) + jitter;

            // request rerun
            core.info(`Scheduling rerun in ${Math.round(delayMs)}ms`);
            return { should_rerun: true, run_id: run.id, delayMs };
      - name: Possibly sleep and rerun
        if: steps.rerun-check.outputs.should_rerun == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const out = steps['rerun-check'].outputs;
            const runId = JSON.parse(out).run_id || context.payload.workflow_run.id;
            const delayMs = JSON.parse(out).delayMs || 0;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const maxAttempts = parseInt(process.env.COPILOT_BOT_MAX_ATTEMPTS || '3', 10);

            if (delayMs > 0) {
              core.info(`Sleeping for ${delayMs}ms before re-run`);
              await new Promise(r => setTimeout(r, delayMs));
            }

            core.info(`Triggering rerun for run ${runId}`);
            await github.rest.actions.reRunWorkflow({ owner, repo, run_id: runId });
            // Post a comment on the PR or commit to notify
            const run = context.payload.workflow_run;
            const head_sha = run.head_sha;
            // find associated PRs
            const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({ owner, repo, commit_sha: head_sha });
            let body = `ðŸ¤– Copilot Bot: re-run triggered for workflow run ${runId} (attempt ${'+'}).`;
            if (prs.data && prs.data.length > 0) {
              for (const pr of prs.data) {
                await github.rest.issues.createComment({ owner, repo, issue_number: pr.number, body });
              }
            } else {
              core.info('No PR associated with this commit; skipping PR comment');
            }
            
            // --- Audit log: write a small markdown artifact with details ---
            try {
              const fs = require('fs');
              const attemptsResp = await github.rest.actions.listWorkflowRunsForRepo({ owner, repo, per_page: 100 });
              const runs = attemptsResp.data.workflow_runs.filter(r => r.workflow_id === run.workflow_id && r.head_sha === head_sha);
              const attempts = runs.length;
              const maxAttemptsEnv = process.env.COPILOT_BOT_MAX_ATTEMPTS || '3';
              const ts = new Date().toISOString();
              const filename = `copilot-bot-log-${Date.now()}.md`;
              const prUrls = (prs.data || []).map(p => `#${p.number} ${p.html_url}`).join('\n') || 'none';
              const contents = [`# Copilot Bot Audit Log`,``,`- timestamp: ${ts}` , `- workflow_name: ${run.name}`, `- workflow_run_id: ${runId}`, `- head_sha: ${head_sha}`, `- attempts_for_head_sha: ${attempts}`, `- max_attempts_allowed: ${maxAttemptsEnv}`, `- scheduled_delay_ms: ${delayMs}`, `- associated_prs:`, prUrls, '', '---', '', 'This file was generated by copilot-bot.yml to record automatic rerun activity.'].join('\n');
              fs.writeFileSync(filename, contents, 'utf8');
              core.info(`Wrote audit log ${filename}`);
            } catch (e) {
              core.warning('Failed to write copilot audit log: ' + e.message);
            }

      - name: Upload copilot-bot audit artifact
        if: steps.rerun-check.outputs.should_rerun == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: copilot-bot-log
          path: copilot-bot-log-*.md
      - name: Upload copilot-bot close artifact
        if: steps.rerun-check.outputs.close_filename != ''
        uses: actions/upload-artifact@v4
        with:
          name: copilot-bot-close
          path: ${{ steps.rerun-check.outputs.close_filename }}
      - name: Open investigation issue after repeated failures
        if: steps.rerun-check.outputs.open_issue == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const title = steps['rerun-check'].outputs.issue_title || `CI auto-rerun alert`;
            const body = steps['rerun-check'].outputs.issue_body || `Auto-rerun reached max attempts.`;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            core.info(`Creating issue: ${title}`);
            const issue = await github.rest.issues.create({ owner, repo, title, body, labels: ['ci','auto-rerun'] });
            core.info(`Created issue: ${issue.data.html_url}`);
      - name: Notify (no-op)
        if: steps.rerun-check.outputs.should_rerun != 'true'
        run: |
          echo "No auto-rerun scheduled for this workflow run."
