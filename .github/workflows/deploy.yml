# This workflow will deploy a backend and frontend application to Google Cloud Run
# Learn more: https://docs.github.com/en/actions/workflows/deploying-applications-to-cloud-run

name: Deploy MedPlat (Local-First ‚Üí Cloud Run)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: deploy-medplat-${{ github.ref }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read

jobs:
  validate-secrets:
    runs-on: ubuntu-latest
    outputs:
      ok: ${{ steps.validate.outputs.ok }}
      auth: ${{ steps.validate.outputs.auth }}
    steps:
      - uses: actions/checkout@v4
      - name: üîê Validate Secrets
        id: validate
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GCP_PROJECT: ${{ secrets.GCP_PROJECT }}
          GCP_SA_KEY: ${{ secrets.GCP_SA_KEY }}
          WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER }}
          WORKLOAD_IDENTITY_SERVICE_ACCOUNT: ${{ secrets.WORKLOAD_IDENTITY_SERVICE_ACCOUNT }}
          FIREBASE_SERVICE_KEY: ${{ secrets.FIREBASE_SERVICE_KEY }}
        run: |
          MISSING=0
          # Required always: OPENAI_API_KEY, GCP_PROJECT, FIREBASE_SERVICE_KEY
          for name in OPENAI_API_KEY GCP_PROJECT FIREBASE_SERVICE_KEY; do
            val="$(printenv "$name")"
            if [ -z "$val" ]; then
              echo "‚ùå $name missing"
              MISSING=$((MISSING+1))
            else
              echo "‚úÖ $name present (len=$(printf '%s' \"$val\" | wc -c))"
            fi
          done

          # For GCP authentication we accept either a service account key JSON
          # in GCP_SA_KEY, or Workload Identity Federation configuration via
          # WORKLOAD_IDENTITY_PROVIDER + WORKLOAD_IDENTITY_SERVICE_ACCOUNT.
          if [ -n "$(printenv GCP_SA_KEY)" ]; then
            echo "‚úÖ GCP_SA_KEY present (service-account key)"
            AUTH="sa"
          elif [ -n "$(printenv WORKLOAD_IDENTITY_PROVIDER)" ] && [ -n "$(printenv WORKLOAD_IDENTITY_SERVICE_ACCOUNT)" ]; then
            echo "‚úÖ Workload Identity provider and service account present"
            AUTH="wif"
          else
            echo "‚ùå GCP auth configuration missing: provide either GCP_SA_KEY or WORKLOAD_IDENTITY_PROVIDER + WORKLOAD_IDENTITY_SERVICE_ACCOUNT"
            MISSING=$((MISSING+1))
          fi

          if [ $MISSING -eq 0 ]; then
            echo "ok=true" >> $GITHUB_OUTPUT
            # export which auth method to use: 'sa' or 'wif'
            # default to 'sa' if both present prefer service-account key (we set AUTH above)
            if [ -z "$AUTH" ]; then
              AUTH="sa"
            fi
            echo "auth=$AUTH" >> $GITHUB_OUTPUT
          else
            echo "ok=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  pre-deploy-check:
    name: Pre-deploy commit-to-main check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Verify running on main branch
        run: |
          # Fetch main to ensure refs are present
          git fetch origin main --depth=1 || true
          CURRENT_BRANCH=${GITHUB_REF##*/}
          echo "Detected GITHUB_REF=$GITHUB_REF -> branch=$CURRENT_BRANCH"
          if [ "$CURRENT_BRANCH" != "main" ]; then
            echo "‚ùå Deployment blocked: workflows must be run from 'main' for production deploys."
            echo "üëâ To deploy: merge your changes into main, then re-run this workflow."
            exit 1
          fi
          echo "‚úÖ On main branch ‚Äî safe to deploy."

  deploy:
    needs: [validate-secrets, pre-deploy-check]
    if: needs.validate-secrets.outputs.ok == 'true' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    env:
      GCP_PROJECT: ${{ secrets.GCP_PROJECT }}
    steps:
      - uses: actions/checkout@v4

      - name: ‚òÅÔ∏è Authenticate to Google Cloud (Workload Identity)
        if: needs.validate-secrets.outputs.auth == 'wif'
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.WORKLOAD_IDENTITY_SERVICE_ACCOUNT }}

      - name: ‚òÅÔ∏è Authenticate to Google Cloud (service account key)
        if: needs.validate-secrets.outputs.auth == 'sa'
        uses: google-github-actions/auth@v2
        with:
          # Provide the raw service-account JSON stored in the Actions secret.
          # The action will create a credentials file when create_credentials_file=true.
          credentials_json: ${{ secrets.GCP_SA_KEY }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set GCP key (write secret to file)
        if: needs.validate-secrets.outputs.auth == 'sa'
        run: |
          # Write the raw service account JSON from the Actions secret to a secure file
          echo "$GCP_SA_KEY" > /tmp/key.json
          chmod 600 /tmp/key.json
        env:
          GCP_SA_KEY: ${{ secrets.GCP_SA_KEY }}

      - name: Write secret files (OPENAI, VITE, BACKEND, WIF)
        run: |
          # Only write files for secrets that are provided; permissions are tightened where appropriate
          if [ -n "${OPENAI_API_KEY:-}" ]; then
            printf '%s' "$OPENAI_API_KEY" > /tmp/openai_key.txt
            chmod 600 /tmp/openai_key.txt
          fi

          if [ -n "${FIREBASE_SERVICE_KEY:-}" ]; then
            printf '%s' "$FIREBASE_SERVICE_KEY" > /tmp/firebase_key.json
            chmod 600 /tmp/firebase_key.json
          fi

          if [ -n "${VITE_API_BASE:-}" ]; then
            printf '%s' "$VITE_API_BASE" > /tmp/vite_api_base.txt
            chmod 600 /tmp/vite_api_base.txt
          fi

          if [ -n "${BACKEND_BASE:-}" ]; then
            printf '%s' "$BACKEND_BASE" > /tmp/backend_base.txt
            chmod 600 /tmp/backend_base.txt
          fi

          if [ -n "${WORKLOAD_IDENTITY_PROVIDER:-}" ]; then
            printf '%s' "$WORKLOAD_IDENTITY_PROVIDER" > /tmp/wif_provider.txt
            chmod 600 /tmp/wif_provider.txt
          fi

          if [ -n "${WORKLOAD_IDENTITY_SERVICE_ACCOUNT:-}" ]; then
            printf '%s' "$WORKLOAD_IDENTITY_SERVICE_ACCOUNT" > /tmp/wif_service_account.txt
            chmod 600 /tmp/wif_service_account.txt
          fi
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          FIREBASE_SERVICE_KEY: ${{ secrets.FIREBASE_SERVICE_KEY }}
          VITE_API_BASE: ${{ secrets.VITE_API_BASE }}
          BACKEND_BASE: ${{ secrets.BACKEND_BASE }}
          WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER }}
          WORKLOAD_IDENTITY_SERVICE_ACCOUNT: ${{ secrets.WORKLOAD_IDENTITY_SERVICE_ACCOUNT }}

      - name: üß∞ Setup gcloud
        uses: google-github-actions/setup-gcloud@v2

      - name: üê≥ Configure Docker for GCR
        run: gcloud auth configure-docker gcr.io

      - name: üîê Ensure Firebase key secret in Secret Manager
        env:
          FIREBASE_SERVICE_KEY: ${{ secrets.FIREBASE_SERVICE_KEY }}
        run: |
          printf '%s' "$FIREBASE_SERVICE_KEY" > /tmp/firebase_key.json
          # Use the actual secret name that exists in Secret Manager
          if gcloud secrets describe FIREBASE_SERVICE_KEY --project=$GCP_PROJECT >/dev/null 2>&1; then
            echo "‚úÖ Secret FIREBASE_SERVICE_KEY exists ‚Äî using existing version"
          else
            echo "Secret FIREBASE_SERVICE_KEY does not exist. Creating initial version..."
            if gcloud secrets create FIREBASE_SERVICE_KEY --data-file=/tmp/firebase_key.json --project=$GCP_PROJECT >/dev/null 2>&1; then
              echo "‚úÖ Created FIREBASE_SERVICE_KEY"
            else
              echo "‚ö†Ô∏è Warning: failed to create FIREBASE_SERVICE_KEY (permission?). Continuing without failing."
            fi
          fi

      - name: üîê Ensure OpenAI key secret in Secret Manager
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          printf '%s' "$OPENAI_API_KEY" > /tmp/openai_key.txt
          # Use the actual secret name that exists in Secret Manager
          if gcloud secrets describe OPENAI_API_KEY --project=$GCP_PROJECT >/dev/null 2>&1; then
            echo "‚úÖ Secret OPENAI_API_KEY exists ‚Äî using existing version"
          else
            echo "Secret OPENAI_API_KEY does not exist. Creating initial version..."
            if gcloud secrets create OPENAI_API_KEY --data-file=/tmp/openai_key.txt --project=$GCP_PROJECT >/dev/null 2>&1; then
              echo "‚úÖ Created OPENAI_API_KEY"
            else
              echo "‚ö†Ô∏è Warning: failed to create OPENAI_API_KEY (permission?). Continuing without failing."
            fi
          fi

      - name: üöÄ Deploy Backend
        run: |
          set -e
          cd backend
          # Retry logic for build (up to 3 attempts)
          MAX_RETRIES=3
          RETRY_COUNT=0
          BUILD_SUCCESS=false
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$BUILD_SUCCESS" = false ]; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "üî® Build attempt $RETRY_COUNT/$MAX_RETRIES"
            if gcloud builds submit --tag gcr.io/$GCP_PROJECT/medplat-backend:latest .; then
              BUILD_SUCCESS=true
              echo "‚úÖ Build successful"
            else
              echo "‚ùå Build failed, retrying..."
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                sleep $((RETRY_COUNT * 10))
              fi
            fi
          done
          if [ "$BUILD_SUCCESS" = false ]; then
            echo "‚ùå Build failed after $MAX_RETRIES attempts"
            exit 1
          fi
          
          # Retry logic for deploy (up to 3 attempts)
          RETRY_COUNT=0
          DEPLOY_SUCCESS=false
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$DEPLOY_SUCCESS" = false ]; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "üöÄ Deploy attempt $RETRY_COUNT/$MAX_RETRIES"
            if gcloud run deploy medplat-backend \
              --image gcr.io/$GCP_PROJECT/medplat-backend:latest \
              --region europe-west1 \
              --allow-unauthenticated \
              --port 8080 \
              --set-secrets "FIREBASE_SERVICE_KEY=FIREBASE_SERVICE_KEY:latest,OPENAI_API_KEY=OPENAI_API_KEY:latest" \
              --update-env-vars "GCP_PROJECT=$GCP_PROJECT,TOPICS_COLLECTION=topics2,NODE_ENV=production" \
              --project $GCP_PROJECT; then
              DEPLOY_SUCCESS=true
              echo "‚úÖ Deploy successful"
            else
              echo "‚ùå Deploy failed, retrying..."
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                sleep $((RETRY_COUNT * 10))
              fi
            fi
          done
          if [ "$DEPLOY_SUCCESS" = false ]; then
            echo "‚ùå Deploy failed after $MAX_RETRIES attempts"
            exit 1
          fi

      - name: üé® Build Frontend (generate artifact)
        id: build_frontend
        run: |
          set -e
          cd frontend
          # THE ONLY CORRECT BACKEND URL
          BACKEND_URL="https://medplat-backend-139218747785.europe-west1.run.app"
          echo "Using backend URL: $BACKEND_URL"
          export VITE_API_BASE=$BACKEND_URL
          npm ci && npm run build
          # Use the environment file mechanism to set step outputs instead of the
          # deprecated ::set-output command.
          echo "backend_url=$BACKEND_URL" >> $GITHUB_OUTPUT

      - name: üîé Verify Frontend Build contains VITE_API_BASE
        run: |
          BACKEND_URL=${{ steps.build_frontend.outputs.backend_url }}
          if [ -f frontend/dist/VITE_API_BASE.txt ]; then
            FOUND=$(cat frontend/dist/VITE_API_BASE.txt)
            echo "Found VITE_API_BASE in artifact: $FOUND"
            if [ "$FOUND" != "$BACKEND_URL" ]; then
              echo "‚ùå Mismatch: expected $BACKEND_URL but frontend/dist/VITE_API_BASE.txt contains $FOUND"
              exit 1
            fi
          else
            echo "‚ùå frontend/dist/VITE_API_BASE.txt not found ‚Äî build step did not produce the verification artifact"
            exit 1
          fi

      - name: üì¶ Upload frontend build artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist

      - name: üöÄ Deploy Frontend
        run: |
          set -e
          BACKEND_URL=${{ steps.build_frontend.outputs.backend_url }}
          cd frontend
          echo "Building frontend with backend URL: $BACKEND_URL"
          
          # Retry logic for build (up to 3 attempts)
          MAX_RETRIES=3
          RETRY_COUNT=0
          BUILD_SUCCESS=false
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$BUILD_SUCCESS" = false ]; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "üî® Frontend build attempt $RETRY_COUNT/$MAX_RETRIES"
            if gcloud builds submit --tag gcr.io/$GCP_PROJECT/medplat-frontend:latest .; then
              BUILD_SUCCESS=true
              echo "‚úÖ Frontend build successful"
            else
              echo "‚ùå Frontend build failed, retrying..."
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                sleep $((RETRY_COUNT * 10))
              fi
            fi
          done
          if [ "$BUILD_SUCCESS" = false ]; then
            echo "‚ùå Frontend build failed after $MAX_RETRIES attempts"
            exit 1
          fi
          
          # Retry logic for deploy (up to 3 attempts)
          RETRY_COUNT=0
          DEPLOY_SUCCESS=false
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$DEPLOY_SUCCESS" = false ]; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "üöÄ Frontend deploy attempt $RETRY_COUNT/$MAX_RETRIES"
            if gcloud run deploy medplat-frontend \
              --image gcr.io/$GCP_PROJECT/medplat-frontend:latest \
              --region europe-west1 \
              --allow-unauthenticated \
              --set-env-vars "VITE_API_BASE=$BACKEND_URL" \
              --project $GCP_PROJECT; then
              DEPLOY_SUCCESS=true
              echo "‚úÖ Frontend deploy successful"
            else
              echo "‚ùå Frontend deploy failed, retrying..."
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                sleep $((RETRY_COUNT * 10))
              fi
            fi
          done
          if [ "$DEPLOY_SUCCESS" = false ]; then
            echo "‚ùå Frontend deploy failed after $MAX_RETRIES attempts"
            exit 1
          fi

      - name: ü©∫ Post-deploy health checks
        run: |
          set -euo pipefail
          echo "Running post-deploy health checks"

          # Ensure services allow unauthenticated invocations (idempotent)
          echo "Ensuring Cloud Run services allow unauthenticated invocations"
          gcloud run services add-iam-policy-binding medplat-frontend --region=europe-west1 --member="allUsers" --role="roles/run.invoker" --project=$GCP_PROJECT || true
          gcloud run services add-iam-policy-binding medplat-backend --region=europe-west1 --member="allUsers" --role="roles/run.invoker" --project=$GCP_PROJECT || true

          resolve_url() {
            svc="$1"
            # re-query the service URL to avoid stale values
            url=$(gcloud run services describe "$svc" --region=europe-west1 --project=$GCP_PROJECT --format='value(status.url)')
            echo "$url"
          }

          check_service() {
            svc="$1"
            name="$2"
            echo "Checking service $svc (friendly name: $name)"
            # allow retry a few times for services that are still warming
            retries=6
            delay=5
            attempt=0
            while : ; do
              url=$(resolve_url "$svc")
              echo "Resolved $svc -> $url"
              if [ -z "$url" ]; then
                echo "No URL returned yet for $svc"
              else
                  status=$(curl -s -o /dev/null -w "%{http_code}" -L --max-time 15 "$url" || true)
                  echo "$name responded with HTTP $status"
                  if [[ "$status" =~ ^2[0-9][0-9]$ ]]; then
                    echo "‚úÖ $name OK"
                    break
                  fi

                  # Try fallback URL with correct project number
                  if [ "$svc" = "medplat-backend" ]; then
                    alt_url="https://medplat-backend-139218747785.europe-west1.run.app"
                  elif [ "$svc" = "medplat-frontend" ]; then
                    alt_url="https://medplat-frontend-139218747785.europe-west1.run.app"
                  else
                    alt_url=""
                  fi
                  if [ -n "$alt_url" ]; then
                    echo "Trying fallback URL: $alt_url"
                    alt_status=$(curl -s -o /dev/null -w "%{http_code}" -L --max-time 15 "$alt_url" || true)
                    echo "$name fallback URL responded with HTTP $alt_status"
                    if [[ "$alt_status" =~ ^2[0-9][0-9]$ ]]; then
                      echo "‚úÖ $name OK via fallback URL ($alt_url)"
                      break
                    else
                      echo "‚ùå $name fallback also returned $alt_status"
                    fi
                  fi
              fi

              attempt=$((attempt+1))
              if [ $attempt -ge $retries ]; then
                echo "$name failed health check after $retries attempts"
                # print some diagnostics
                echo "Diagnostics: describe and IAM policy for $svc"
                gcloud run services describe "$svc" --region=europe-west1 --project=$GCP_PROJECT || true
                gcloud run services get-iam-policy "$svc" --region=europe-west1 --project=$GCP_PROJECT || true
                exit 1
              fi
              echo "Retrying $name in $delay seconds... (attempt $attempt/$retries)"
              sleep $delay
            done
          }

          check_service medplat-frontend frontend
          check_service medplat-backend backend

      - name: üìä Summary
        run: |
          BACKEND_URL=$(gcloud run services describe medplat-backend --region=europe-west1 --format='value(status.url)')
          FRONTEND_URL=$(gcloud run services describe medplat-frontend --region=europe-west1 --format='value(status.url)')
          echo "‚úÖ Backend: $BACKEND_URL"
          echo "‚úÖ Frontend: $FRONTEND_URL"
          echo "üéØ MedPlat deployment successful"

      - name: Frontend‚ÜîBackend connectivity test
        run: |
          echo "üåê Testing deployed frontend‚Üíbackend connectivity..."
          set -euo pipefail
          # Allow a soft-fail mode via environment variable (set to 'true' to avoid failing the workflow)
          SOFT_FAIL=${SOFT_FAIL_CONNECTIVITY:-false}

          FRONTEND_URL=$(gcloud run services describe medplat-frontend --region=europe-west1 --format='value(status.url)')
          BACKEND_URL=$(gcloud run services describe medplat-backend --region=europe-west1 --format='value(status.url)')
          echo "Frontend URL: $FRONTEND_URL"
          echo "Backend URL: $BACKEND_URL"

          echo "‚Üí Quick check: frontend root (non-blocking)"
          if ! curl -fsSL -I "$FRONTEND_URL/" | head -n 1; then
            echo "‚ö†Ô∏è Frontend root returned non-2xx or unreachable"
          else
            echo "‚úÖ Frontend root reachable"
          fi

          # Helper: retry GET endpoints (3 attempts, exponential backoff) with jitter (¬± up to 1s)
          retry_get() {
            endpoint="$1"
            for i in 1 2 3; do
              if curl -fsSL "$BACKEND_URL/$endpoint" -o /dev/null; then
                echo "‚úÖ $endpoint OK"
                return 0
              else
                echo "Attempt $i failed for $endpoint"
                base_sleep=$((2**i))
                jitter=$(( (RANDOM % 3) - 1 )) # -1,0,1
                sleep_time=$((base_sleep + jitter))
                if [ $sleep_time -gt 0 ]; then
                  echo "Sleeping ${sleep_time}s before retry..."
                  sleep $sleep_time
                fi
              fi
            done
            echo "‚ùå $endpoint unreachable after retries"
            return 1
          }

          # Helper: retry POST endpoints similarly
          retry_post() {
            endpoint="$1"
            data="$2"
            for i in 1 2 3; do
              if curl -fsSL -X POST "$BACKEND_URL/$endpoint" -H "Content-Type: application/json" -d "$data" -o /dev/null; then
                echo "‚úÖ $endpoint OK"
                return 0
              else
                echo "Attempt $i failed for $endpoint"
                base_sleep=$((2**i))
                jitter=$(( (RANDOM % 3) - 1 ))
                sleep_time=$((base_sleep + jitter))
                if [ $sleep_time -gt 0 ]; then
                  echo "Sleeping ${sleep_time}s before retry..."
                  sleep $sleep_time
                fi
              fi
            done
            echo "‚ùå $endpoint unreachable after retries"
            return 1
          }

          # Run checks; honor soft-fail if configured
          if ! retry_get "health"; then
            if [ "$SOFT_FAIL" = "true" ]; then
              echo "‚ö†Ô∏è /health unreachable but SOFT_FAIL enabled ‚Äî continuing"
            else
              echo "‚ùå /health unreachable ‚Äî failing deploy"
              exit 1
            fi
          fi

          if ! retry_get "api/topics2/categories"; then
            if [ "$SOFT_FAIL" = "true" ]; then
              echo "‚ö†Ô∏è /api/topics2/categories unreachable but SOFT_FAIL enabled ‚Äî continuing"
            else
              echo "‚ùå /api/topics2/categories unreachable ‚Äî failing deploy"
              exit 1
            fi
          fi

      - name: üß™ Auto-validation: CORS and API endpoints
        run: |
          set -e
          echo "üîç Running auto-validation tests..."
          BACKEND_URL=$(gcloud run services describe medplat-backend --region=europe-west1 --project=$GCP_PROJECT --format='value(status.url)')
          FRONTEND_URL=$(gcloud run services describe medplat-frontend --region=europe-west1 --project=$GCP_PROJECT --format='value(status.url)')
          
          echo "Backend URL: $BACKEND_URL"
          echo "Frontend URL: $FRONTEND_URL"
          
          # Wait for services to be ready
          echo "‚è≥ Waiting for services to be ready..."
          sleep 10
          
          # Test 1: CORS headers on OPTIONS preflight
          echo ""
          echo "üß™ Test 1: CORS OPTIONS preflight"
          CORS_HEADERS=$(curl -s -I -X OPTIONS "$BACKEND_URL/api/topics2/categories" \
            -H "Origin: $FRONTEND_URL" \
            -H "Access-Control-Request-Method: GET" \
            -H "Access-Control-Request-Headers: Content-Type" || echo "")
          
          if echo "$CORS_HEADERS" | grep -qi "access-control-allow-origin"; then
            echo "‚úÖ CORS headers present"
            echo "$CORS_HEADERS" | grep -i "access-control" || true
          else
            echo "‚ùå CORS headers missing or incorrect"
            echo "Response headers:"
            echo "$CORS_HEADERS"
            exit 1
          fi
          
          # Test 2: CORS = * on actual GET request
          echo ""
          echo "üß™ Test 2: CORS header on GET request (expect Access-Control-Allow-Origin: *)"
          CORS_GET=$(curl -s -I "$BACKEND_URL/api/topics2/categories" || echo "")
          if echo "$CORS_GET" | grep -qi "access-control-allow-origin: \*"; then
            echo "‚úÖ CORS = * found in response"
          else
            echo "‚ö†Ô∏è  CORS header may not be * (checking for any CORS header)"
            if echo "$CORS_GET" | grep -qi "access-control-allow-origin"; then
              echo "‚úÖ CORS header present (may be specific origin)"
              echo "$CORS_GET" | grep -i "access-control-allow-origin" || true
            else
              echo "‚ùå No CORS header found"
              echo "Response headers:"
              echo "$CORS_GET"
              exit 1
            fi
          fi
          
          # Test 3: /api/topics2/categories endpoint returns data
          echo ""
          echo "üß™ Test 3: /api/topics2/categories endpoint"
          MAX_RETRIES=5
          RETRY_COUNT=0
          ENDPOINT_SUCCESS=false
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$ENDPOINT_SUCCESS" = false ]; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "Attempt $RETRY_COUNT/$MAX_RETRIES"
            HTTP_CODE=$(curl -s -o /tmp/categories_response.json -w "%{http_code}" "$BACKEND_URL/api/topics2/categories" || echo "000")
            if [ "$HTTP_CODE" = "200" ]; then
              if [ -s /tmp/categories_response.json ]; then
                RESPONSE_SIZE=$(wc -c < /tmp/categories_response.json)
                echo "‚úÖ Endpoint returned 200 OK (response size: $RESPONSE_SIZE bytes)"
                ENDPOINT_SUCCESS=true
              else
                echo "‚ö†Ô∏è  Endpoint returned 200 but empty response"
              fi
            else
              echo "‚ùå Endpoint returned HTTP $HTTP_CODE"
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                sleep $((RETRY_COUNT * 5))
              fi
            fi
          done
          
          if [ "$ENDPOINT_SUCCESS" = false ]; then
            echo "‚ùå /api/topics2/categories endpoint validation failed"
            exit 1
          fi
          
          # Test 4: Frontend loads without CORS errors
          echo ""
          echo "üß™ Test 4: Frontend accessibility"
          FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$FRONTEND_URL/" || echo "000")
          if [ "$FRONTEND_STATUS" = "200" ] || [ "$FRONTEND_STATUS" = "304" ]; then
            echo "‚úÖ Frontend is accessible (HTTP $FRONTEND_STATUS)"
          else
            echo "‚ö†Ô∏è  Frontend returned HTTP $FRONTEND_STATUS (may still be starting)"
          fi
          
          echo ""
          echo "‚úÖ All auto-validation tests passed!"

      - name: üß™ Post-deploy smoke tests
        id: smoke
        run: |
          echo "Running post-deploy smoke tests"
          # Ensure an artifact path output is set even if the smoke script fails
          # so the upload-artifact step has a non-empty 'path' input. The upload
          # will warn if no files are present but won't fail with a missing input.
          echo "artifact=tmp" >> $GITHUB_OUTPUT
          FRONTEND_URL=$(gcloud run services describe medplat-frontend --region=europe-west1 --format='value(status.url)')
          BACKEND_URL=$(gcloud run services describe medplat-backend --region=europe-west1 --format='value(status.url)')
          # THE ONLY CORRECT BACKEND URL
          FRONTEND_FALLBACK="https://medplat-frontend-139218747785.europe-west1.run.app"
          BACKEND_FALLBACK="https://medplat-backend-139218747785.europe-west1.run.app"
          echo "Frontend URL: $FRONTEND_URL"
          echo "Frontend fallback: $FRONTEND_FALLBACK"
          echo "Backend URL: $BACKEND_URL"
          echo "Backend fallback: $BACKEND_FALLBACK"
          mkdir -p tmp
          if [ -f scripts/post_deploy_smoke_test.mjs ]; then
            node scripts/post_deploy_smoke_test.mjs "$FRONTEND_URL" "$FRONTEND_FALLBACK" "$BACKEND_URL" "$BACKEND_FALLBACK" 2>&1 | tee tmp/smoke-output.txt
          else
            echo "‚ö†Ô∏è  post_deploy_smoke_test.mjs not found, skipping"
            echo "smoke-test-skipped" > tmp/smoke-output.txt
          fi
          echo "artifact=tmp" >> $GITHUB_OUTPUT

      - name: üì¶ Upload smoke test artifacts (if present)
        # Only attempt upload if the smoke step produced an artifact path. When the
        # smoke step fails or didn't set the output, the upload action would error
        # with "Input required and not supplied: path". Use a conditional to skip
        # the upload when there is no artifact output.
        if: always() && steps.smoke.outputs.artifact != ''
        uses: actions/upload-artifact@v4
        with:
          name: smoke-test-artifacts
          path: ${{ steps.smoke.outputs.artifact }}
