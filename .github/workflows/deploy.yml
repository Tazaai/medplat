# This workflow will deploy a backend and frontend application to Google Cloud Run
# Learn more: https://docs.github.com/en/actions/workflows/deploying-applications-to-cloud-run

name: Deploy MedPlat (Local-First ‚Üí Cloud Run)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: deploy-medplat-${{ github.ref }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read

jobs:
  validate-secrets:
    runs-on: ubuntu-latest
    outputs:
      ok: ${{ steps.validate.outputs.ok }}
      auth: ${{ steps.validate.outputs.auth }}
    steps:
      - uses: actions/checkout@v4
      - name: üîê Validate Secrets
        id: validate
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GCP_PROJECT: ${{ secrets.GCP_PROJECT }}
          GCP_SA_KEY: ${{ secrets.GCP_SA_KEY }}
          WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER }}
          WORKLOAD_IDENTITY_SERVICE_ACCOUNT: ${{ secrets.WORKLOAD_IDENTITY_SERVICE_ACCOUNT }}
          FIREBASE_SERVICE_KEY: ${{ secrets.FIREBASE_SERVICE_KEY }}
        run: |
          MISSING=0
          # Required always: OPENAI_API_KEY, GCP_PROJECT, FIREBASE_SERVICE_KEY
          for name in OPENAI_API_KEY GCP_PROJECT FIREBASE_SERVICE_KEY; do
            val="$(printenv "$name")"
            if [ -z "$val" ]; then
              echo "‚ùå $name missing"
              MISSING=$((MISSING+1))
            else
              echo "‚úÖ $name present (len=$(printf '%s' \"$val\" | wc -c))"
            fi
          done

          # For GCP authentication we accept either a service account key JSON
          # in GCP_SA_KEY, or Workload Identity Federation configuration via
          # WORKLOAD_IDENTITY_PROVIDER + WORKLOAD_IDENTITY_SERVICE_ACCOUNT.
          if [ -n "$(printenv GCP_SA_KEY)" ]; then
            echo "‚úÖ GCP_SA_KEY present (service-account key)"
            AUTH="sa"
          elif [ -n "$(printenv WORKLOAD_IDENTITY_PROVIDER)" ] && [ -n "$(printenv WORKLOAD_IDENTITY_SERVICE_ACCOUNT)" ]; then
            echo "‚úÖ Workload Identity provider and service account present"
            AUTH="wif"
          else
            echo "‚ùå GCP auth configuration missing: provide either GCP_SA_KEY or WORKLOAD_IDENTITY_PROVIDER + WORKLOAD_IDENTITY_SERVICE_ACCOUNT"
            MISSING=$((MISSING+1))
          fi

          if [ $MISSING -eq 0 ]; then
            echo "ok=true" >> $GITHUB_OUTPUT
            # export which auth method to use: 'sa' or 'wif'
            # default to 'sa' if both present prefer service-account key (we set AUTH above)
            if [ -z "$AUTH" ]; then
              AUTH="sa"
            fi
            echo "auth=$AUTH" >> $GITHUB_OUTPUT
          else
            echo "ok=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  deploy:
    needs: validate-secrets
    if: needs.validate-secrets.outputs.ok == 'true' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    env:
      GCP_PROJECT: ${{ secrets.GCP_PROJECT }}
    steps:
      - uses: actions/checkout@v4

      - name: ‚òÅÔ∏è Authenticate to Google Cloud (Workload Identity)
        if: needs.validate-secrets.outputs.auth == 'wif'
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.WORKLOAD_IDENTITY_SERVICE_ACCOUNT }}

      - name: ‚òÅÔ∏è Authenticate to Google Cloud (service account key)
        if: needs.validate-secrets.outputs.auth == 'sa'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: üß∞ Setup gcloud
        uses: google-github-actions/setup-gcloud@v2

      - name: üê≥ Configure Artifact Registry
        run: gcloud auth configure-docker europe-west1-docker.pkg.dev

      - name: üîê Ensure Firebase key secret in Secret Manager
        env:
          FIREBASE_SERVICE_KEY: ${{ secrets.FIREBASE_SERVICE_KEY }}
        run: |
          printf '%s' "$FIREBASE_SERVICE_KEY" > /tmp/firebase_key.json
          if ! gcloud secrets describe medplat-firebase-key --project=$GCP_PROJECT >/dev/null 2>&1; then
            gcloud secrets create medplat-firebase-key --data-file=/tmp/firebase_key.json --project=$GCP_PROJECT
          else
            gcloud secrets versions add medplat-firebase-key --data-file=/tmp/firebase_key.json --project=$GCP_PROJECT
          fi

      - name: üîê Ensure OpenAI key secret in Secret Manager
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          printf '%s' "$OPENAI_API_KEY" > /tmp/openai_key.txt
          if ! gcloud secrets describe medplat-openai-key --project=$GCP_PROJECT >/dev/null 2>&1; then
            gcloud secrets create medplat-openai-key --data-file=/tmp/openai_key.txt --project=$GCP_PROJECT
          else
            gcloud secrets versions add medplat-openai-key --data-file=/tmp/openai_key.txt --project=$GCP_PROJECT
          fi

      - name: üöÄ Deploy Backend
        run: |
          cd backend
          gcloud builds submit --tag europe-west1-docker.pkg.dev/$GCP_PROJECT/medplat/backend .
          gcloud run deploy medplat-backend \
            --image europe-west1-docker.pkg.dev/$GCP_PROJECT/medplat/backend \
            --region europe-west1 \
            --allow-unauthenticated \
            --port 8080 \
            --set-secrets "OPENAI_API_KEY=medplat-openai-key:latest,FIREBASE_SERVICE_KEY=medplat-firebase-key:latest" \
            --project $GCP_PROJECT

      - name: üé® Build Frontend (generate artifact)
        id: build_frontend
        run: |
          cd frontend
          BACKEND_URL=$(gcloud run services describe medplat-backend --region=europe-west1 --project=$GCP_PROJECT --format='value(status.url)')
          echo "Detected backend URL: $BACKEND_URL"
          export VITE_API_BASE=$BACKEND_URL
          npm ci && npm run build
          echo "::set-output name=backend_url::$BACKEND_URL"

      - name: üîé Verify Frontend Build contains VITE_API_BASE
        run: |
          BACKEND_URL=${{ steps.build_frontend.outputs.backend_url }}
          if [ -f frontend/dist/VITE_API_BASE.txt ]; then
            FOUND=$(cat frontend/dist/VITE_API_BASE.txt)
            echo "Found VITE_API_BASE in artifact: $FOUND"
            if [ "$FOUND" != "$BACKEND_URL" ]; then
              echo "‚ùå Mismatch: expected $BACKEND_URL but frontend/dist/VITE_API_BASE.txt contains $FOUND"
              exit 1
            fi
          else
            echo "‚ùå frontend/dist/VITE_API_BASE.txt not found ‚Äî build step did not produce the verification artifact"
            exit 1
          fi

      - name: üì¶ Upload frontend build artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist

      - name: üöÄ Deploy Frontend
        run: |
          BACKEND_URL=${{ steps.build_frontend.outputs.backend_url }}
          cd frontend
          # Build docker image and deploy to Cloud Run (this will rebuild the frontend into the container)
          gcloud builds submit --tag europe-west1-docker.pkg.dev/$GCP_PROJECT/medplat/frontend .
          gcloud run deploy medplat-frontend \
            --image europe-west1-docker.pkg.dev/$GCP_PROJECT/medplat/frontend \
            --region europe-west1 \
            --allow-unauthenticated \
            --port 8080 \
            --set-env-vars "VITE_API_BASE=$BACKEND_URL" \
            --project $GCP_PROJECT

      - name: üìä Summary
        run: |
          BACKEND_URL=$(gcloud run services describe medplat-backend --region=europe-west1 --format='value(status.url)')
          FRONTEND_URL=$(gcloud run services describe medplat-frontend --region=europe-west1 --format='value(status.url)')
          echo "‚úÖ Backend: $BACKEND_URL"
          echo "‚úÖ Frontend: $FRONTEND_URL"
          echo "üéØ MedPlat deployment successful"